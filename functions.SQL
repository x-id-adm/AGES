-- =================================================================================================
-- MÃ“DULO: FUNÃ‡Ã•ES E GATILHOS DO WORKFLOW AGES
-- =================================================================================================
-- DESCRIÃ‡ÃƒO: 
--   Este mÃ³dulo centraliza todas as funÃ§Ãµes de negÃ³cio e triggers do sistema AGES.
--   ResponsÃ¡vel por:
--   - SincronizaÃ§Ã£o de dados entre tabelas
--   - GeraÃ§Ã£o de IDs amigÃ¡veis sequenciais
--   - AtualizaÃ§Ã£o automÃ¡tica de timestamps
--   - ManutenÃ§Ã£o de integridade referencial
-- -------------------------------------------------------------------------------------------------
-- VERSÃƒO: 1.1
-- DATA: 2025-11-14
-- -------------------------------------------------------------------------------------------------

-- =================================================================================================
-- SEÃ‡ÃƒO 1: FUNÃ‡Ã•ES DE NEGÃ“CIO
-- =================================================================================================
-- Esta seÃ§Ã£o contÃ©m as funÃ§Ãµes principais do sistema, organizadas por responsabilidade:
--
-- 1.1 SINCRONIZAÃ‡ÃƒO DE DADOS
--     â””â”€ func_upsert_contact_from_webhook ........ Sincroniza dados do Webhook PING
--     â””â”€ func_sync_owner_to_cell_sheet ........... Propaga whatsapp_owner para cell_phone
--
-- 1.2 GERAÃ‡ÃƒO DE IDS AMIGÃVEIS
--     â””â”€ func_generate_friendly_client_id ........ Gera IDs tipo "CT1", "CT2"...
--     â””â”€ func_generate_friendly_service_id ....... Gera IDs tipo "AT1", "AT2"...
--
-- 1.3 MARCAÃ‡ÃƒO AUTOMÃTICA DE PRIMÃRIO
--     â””â”€ func_ensure_first_is_primary ............ Garante primeiro registro como primÃ¡rio
--
-- 1.4 AUTOMAÃ‡ÃƒO DE MENSAGENS
--     â””â”€ func_generate_ulid ....................... Gera ULID para rastreio
--     â””â”€ func_auto_populate_message_fields ........ Preenche source_message_id e tsvector
--
-- 1.5 UTILITÃRIOS AUTOMÃTICOS
--     â””â”€ update_updated_at_column ................ Atualiza campo updated_at automaticamente
-- =================================================================================================


-- -------------------------------------------------------------------------------------------------
-- 1.1 SINCRONIZAÃ‡ÃƒO DE DADOS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_upsert_contact_from_webhook                                                    â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Sincroniza dados recebidos do Webhook PING com as tabelas locais de forma atÃ´mica.        â”‚
-- â”‚   Realiza UPSERT em duas tabelas: inbox e contatos.                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0a_inbox_whatsapp ............. (INSERT/UPDATE) Dados da inbox                          â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact ...... (INSERT/UPDATE) Dados do contato                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ OperaÃ§Ã£o atÃ´mica (tudo ou nada)                                                         â”‚
-- â”‚   âœ“ Idempotente (pode ser executada mÃºltiplas vezes com seguranÃ§a)                          â”‚
-- â”‚   âœ“ Usa COALESCE para preservar dados existentes quando o parÃ¢metro Ã© NULL                  â”‚
-- â”‚   âœ“ Atualiza updated_at automaticamente                                                     â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_upsert_contact_from_webhook(
  p_inbox_id             UUID,
  p_owner_wallet_id      UUID,
  p_client_name          TEXT DEFAULT NULL,
  p_inbox_name           TEXT DEFAULT NULL,
  p_avatar_inbox_url     TEXT DEFAULT NULL,
  p_login_identity       TEXT DEFAULT NULL,
  p_status_workflow      workflow_status DEFAULT 'ğŸŸ¢',
  p_avatar_agent_url     TEXT DEFAULT NULL,
  p_name_agent           TEXT DEFAULT NULL,
  p_bio_agent            TEXT DEFAULT NULL,
  p_monthly_limit        BIGINT DEFAULT 0,
  p_credits_used         BIGINT DEFAULT 0,
  p_remaining_credits    BIGINT DEFAULT 0,
  p_wallet_id            UUID DEFAULT NULL,
  p_status_contact       workflow_status DEFAULT 'ğŸŸ¢',
  p_status_agent         workflow_status DEFAULT 'ğŸŸ¢',
  p_push_name            TEXT DEFAULT NULL,
  p_latest_avatar_url    TEXT DEFAULT NULL,
  p_phone_number         TEXT DEFAULT NULL,
  p_country_flag_emoji   TEXT DEFAULT NULL,
  p_country_code         VARCHAR DEFAULT NULL,
  p_area_code            VARCHAR DEFAULT NULL,
  p_contact_message_count BIGINT DEFAULT 0,
  p_ai_engagement        BIGINT DEFAULT 0,
  p_human_engagement     BIGINT DEFAULT 0,
  p_engagement_score     FLOAT DEFAULT 0.0,
  p_last_interaction_at  TIMESTAMPTZ DEFAULT NULL,
  p_source_device        TEXT DEFAULT NULL,
  p_energy_daily_credit  BIGINT DEFAULT 0,
  p_energy_current_balance BIGINT DEFAULT 0,
  p_tags                 JSONB DEFAULT '[]'::jsonb,
  p_condensed_memory     JSONB DEFAULT '[]'::jsonb
)
RETURNS void AS $$
BEGIN
  -- ValidaÃ§Ã£o de parÃ¢metros obrigatÃ³rios
  IF p_inbox_id IS NULL OR p_owner_wallet_id IS NULL OR p_wallet_id IS NULL THEN
    RAISE EXCEPTION 'ParÃ¢metros obrigatÃ³rios faltando: inbox_id, owner_wallet_id, wallet_id';
  END IF;

  -- UPSERT Inbox (atÃ´mico e idempotente)
  INSERT INTO "0a_inbox_whatsapp" (
    inbox_id, owner_wallet_id, client_name, inbox_name, avatar_inbox_url,
    login_identity, status_workflow, avatar_agent_url, name_agent, bio_agent,
    monthly_limit, credits_used, remaining_credits, updated_at
  )
  VALUES (
    p_inbox_id, p_owner_wallet_id, p_client_name, p_inbox_name, p_avatar_inbox_url,
    p_login_identity, p_status_workflow, p_avatar_agent_url, p_name_agent, p_bio_agent,
    p_monthly_limit, p_credits_used, p_remaining_credits, NOW()
  )
  ON CONFLICT (inbox_id) DO UPDATE SET
    client_name = COALESCE(EXCLUDED.client_name, "0a_inbox_whatsapp".client_name),
    inbox_name = COALESCE(EXCLUDED.inbox_name, "0a_inbox_whatsapp".inbox_name),
    avatar_inbox_url = COALESCE(EXCLUDED.avatar_inbox_url, "0a_inbox_whatsapp".avatar_inbox_url),
    login_identity = COALESCE(EXCLUDED.login_identity, "0a_inbox_whatsapp".login_identity),
    status_workflow = COALESCE(EXCLUDED.status_workflow, "0a_inbox_whatsapp".status_workflow),
    avatar_agent_url = COALESCE(EXCLUDED.avatar_agent_url, "0a_inbox_whatsapp".avatar_agent_url),
    name_agent = COALESCE(EXCLUDED.name_agent, "0a_inbox_whatsapp".name_agent),
    bio_agent = COALESCE(EXCLUDED.bio_agent, "0a_inbox_whatsapp".bio_agent),
    monthly_limit = COALESCE(EXCLUDED.monthly_limit, "0a_inbox_whatsapp".monthly_limit),
    credits_used = COALESCE(EXCLUDED.credits_used, "0a_inbox_whatsapp".credits_used),
    remaining_credits = COALESCE(EXCLUDED.remaining_credits, "0a_inbox_whatsapp".remaining_credits),
    updated_at = NOW();

  -- UPSERT Contato (atÃ´mico e idempotente)
  INSERT INTO "1a_whatsapp_user_contact" (
    wallet_id, inbox_id, status_contact, status_agent, push_name, latest_avatar_url,
    phone_number, country_flag_emoji, country_code, area_code, contact_message_count,
    ai_engagement, human_engagement, engagement_score, last_interaction_at,
    source_device, energy_daily_credit, energy_current_balance, tags, condensed_memory, updated_at
  )
  VALUES (
    p_wallet_id, p_inbox_id, p_status_contact, p_status_agent, p_push_name, p_latest_avatar_url,
    p_phone_number, p_country_flag_emoji, p_country_code, p_area_code, p_contact_message_count,
    p_ai_engagement, p_human_engagement, p_engagement_score, p_last_interaction_at,
    p_source_device, p_energy_daily_credit, p_energy_current_balance, p_tags, p_condensed_memory, NOW()
  )
  ON CONFLICT (wallet_id) DO UPDATE SET
    status_contact = COALESCE(EXCLUDED.status_contact, "1a_whatsapp_user_contact".status_contact),
    status_agent = COALESCE(EXCLUDED.status_agent, "1a_whatsapp_user_contact".status_agent),
    push_name = COALESCE(EXCLUDED.push_name, "1a_whatsapp_user_contact".push_name),
    latest_avatar_url = COALESCE(EXCLUDED.latest_avatar_url, "1a_whatsapp_user_contact".latest_avatar_url),
    phone_number = COALESCE(EXCLUDED.phone_number, "1a_whatsapp_user_contact".phone_number),
    country_flag_emoji = COALESCE(EXCLUDED.country_flag_emoji, "1a_whatsapp_user_contact".country_flag_emoji),
    country_code = COALESCE(EXCLUDED.country_code, "1a_whatsapp_user_contact".country_code),
    area_code = COALESCE(EXCLUDED.area_code, "1a_whatsapp_user_contact".area_code),
    contact_message_count = COALESCE(EXCLUDED.contact_message_count, "1a_whatsapp_user_contact".contact_message_count),
    ai_engagement = COALESCE(EXCLUDED.ai_engagement, "1a_whatsapp_user_contact".ai_engagement),
    human_engagement = COALESCE(EXCLUDED.human_engagement, "1a_whatsapp_user_contact".human_engagement),
    engagement_score = COALESCE(EXCLUDED.engagement_score, "1a_whatsapp_user_contact".engagement_score),
    last_interaction_at = COALESCE(EXCLUDED.last_interaction_at, "1a_whatsapp_user_contact".last_interaction_at),
    source_device = COALESCE(EXCLUDED.source_device, "1a_whatsapp_user_contact".source_device),
    energy_daily_credit = COALESCE(EXCLUDED.energy_daily_credit, "1a_whatsapp_user_contact".energy_daily_credit),
    energy_current_balance = COALESCE(EXCLUDED.energy_current_balance, "1a_whatsapp_user_contact".energy_current_balance),
    tags = COALESCE(EXCLUDED.tags, "1a_whatsapp_user_contact".tags),
    condensed_memory = COALESCE(EXCLUDED.condensed_memory, "1a_whatsapp_user_contact".condensed_memory),
    updated_at = NOW();

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro na funÃ§Ã£o func_upsert_contact_from_webhook: % - %', SQLERRM, SQLSTATE;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_sync_owner_to_cell_sheet                                                       â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Sincroniza automaticamente o campo 'whatsapp_owner' da tabela 3a para a tabela 3b.        â”‚
-- â”‚   Garante que toda ficha de cliente tenha pelo menos um telefone WhatsApp associado.        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FLUXO:                                                                                      â”‚
-- â”‚   1. Busca o wallet_id na tabela 1a usando phone_number e inbox_id                          â”‚
-- â”‚   2. Se encontrar, faz UPSERT na tabela 3b com is_primary=TRUE                              â”‚
-- â”‚   3. Se nÃ£o encontrar, apenas retorna (aguarda criaÃ§Ã£o do contato)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact ...... (SELECT) Busca wallet_id pelo telefone                  â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service .. (INSERT/UPDATE) Registra telefone primÃ¡rio              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Usada como funÃ§Ã£o de TRIGGER (retorna TRIGGER)                                          â”‚
-- â”‚   â€¢ Executa AFTER INSERT/UPDATE na tabela 3a_customer_root_record                           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_sync_owner_to_cell_sheet()
RETURNS TRIGGER AS $$
DECLARE
    v_wallet_id UUID;
BEGIN
    -- Busca wallet_id do contato usando phone_number e inbox_id
    SELECT wallet_id INTO v_wallet_id
    FROM "1a_whatsapp_user_contact"
    WHERE phone_number = NEW.whatsapp_owner
      AND inbox_id = NEW.inbox_id
    LIMIT 1;

    -- Se o contato ainda nÃ£o existe na tabela 1a, apenas retorna
    IF v_wallet_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- UPSERT do telefone na tabela 3b marcando como primÃ¡rio
    INSERT INTO "3b_cell_phone_linked_service_sheet" (
        root_id,
        wallet_id,
        cell_phone,
        is_primary,
        is_whatsapp,
        verified
    )
    VALUES (
        NEW.id,
        v_wallet_id,
        NEW.whatsapp_owner,
        TRUE,
        TRUE,
        TRUE
    )
    ON CONFLICT (root_id, wallet_id) DO UPDATE SET
        cell_phone = EXCLUDED.cell_phone,
        is_primary = EXCLUDED.is_primary,
        is_whatsapp = EXCLUDED.is_whatsapp,
        verified = EXCLUDED.verified,
        updated_at = NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.2 GERAÃ‡ÃƒO DE IDS AMIGÃVEIS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_client_id                                                    â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para clientes no formato "CT1", "CT2", "CT3"...            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   1. Incrementa atomicamente o contador 'client_count' na tabela 0b_inbox_counters          â”‚
-- â”‚   2. Atribui o valor formatado ao campo 'client_id' do registro sendo inserido              â”‚
-- â”‚   3. Se a inbox nÃ£o tem contador, cria um iniciando em 1                                    â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Thread-safe (usa UPDATE ... RETURNING para atomicidade)                                 â”‚
-- â”‚   âœ“ Cada inbox tem sua prÃ³pria sequÃªncia independente                                       â”‚
-- â”‚   âœ“ Usada como funÃ§Ã£o de TRIGGER (BEFORE INSERT)                                            â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_client_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET client_count = client_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING client_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, new_count, 0)
        ON CONFLICT (inbox_id) DO NOTHING;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.client_id := 'CT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_service_id                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para atendimentos no formato "AT1", "AT2", "AT3"...        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   IdÃªntico Ã  func_generate_friendly_client_id, mas usa o contador 'atendimento_count'       â”‚
-- â”‚   e gera IDs com prefixo "AT" (Atendimento)                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_service_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET atendimento_count = atendimento_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING atendimento_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, 0, new_count)
        ON CONFLICT (inbox_id) DO UPDATE 
        SET atendimento_count = new_count;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.service_id := 'AT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.3 MARCAÃ‡ÃƒO AUTOMÃTICA DE PRIMÃRIO
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_ensure_first_is_primary                                                        â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Garante que o PRIMEIRO registro inserido para uma ficha (root_id) seja automaticamente    â”‚
-- â”‚   marcado como primÃ¡rio (is_primary = TRUE).                                                â”‚
-- â”‚   Registros subsequentes mantÃªm is_primary = FALSE por padrÃ£o.                              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   1. Verifica se jÃ¡ existe algum registro para aquele root_id                               â”‚
-- â”‚   2. Se NÃƒO existir nenhum â†’ forÃ§a is_primary = TRUE (Ã© o primeiro!)                        â”‚
-- â”‚   3. Se JÃ existir algum â†’ mantÃ©m o valor informado (padrÃ£o FALSE)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ APLICÃVEL EM:                                                                               â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service_sheet ... Primeiro telefone                                â”‚
-- â”‚   â€¢ 3e_email ............................ Primeiro e-mail                                   â”‚
-- â”‚   â€¢ 3f_landline_phone ................... Primeiro telefone fixo                            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ GenÃ©rica (funciona em qualquer tabela com root_id e is_primary)                         â”‚
-- â”‚   âœ“ Executa BEFORE INSERT                                                                   â”‚
-- â”‚   âœ“ NÃ£o interfere se o usuÃ¡rio explicitamente definir is_primary = TRUE                     â”‚
-- â”‚   âœ“ Idempotente e thread-safe                                                               â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_ensure_first_is_primary()
RETURNS TRIGGER AS $$
DECLARE
    v_count INT;
BEGIN
    -- Conta quantos registros jÃ¡ existem para este root_id
    EXECUTE format('SELECT COUNT(*) FROM %I WHERE root_id = $1', TG_TABLE_NAME)
    INTO v_count
    USING NEW.root_id;
    
    -- Se nÃ£o existir nenhum registro, este Ã© o primeiro â†’ forÃ§a is_primary = TRUE
    IF v_count = 0 THEN
        NEW.is_primary := TRUE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.4 AUTOMAÃ‡ÃƒO DE MENSAGENS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_ulid                                                                  â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera um ULID (Universally Unique Lexicographically Sortable Identifier) para              â”‚
-- â”‚   rastreamento interno de mensagens.                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS DO ULID:                                                                    â”‚
-- â”‚   â€¢ 26 caracteres (Base32)                                                                  â”‚
-- â”‚   â€¢ OrdenÃ¡vel cronologicamente (timestamp nos primeiros 10 chars)                           â”‚
-- â”‚   â€¢ Mais legÃ­vel que UUID                                                                   â”‚
-- â”‚   â€¢ CompatÃ­vel com Ã­ndices de string                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FORMATO:                                                                                    â”‚
-- â”‚   TTTTTTTTTTRRRRRRRRRRRRRRRR                                                                â”‚
-- â”‚   â””â”€ 10 chars timestamp (milissegundos desde epoch)                                         â”‚
-- â”‚              â””â”€ 16 chars aleatÃ³rios                                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO:                                                                                    â”‚
-- â”‚   01HW5Z8K7F9G2M3N4P5Q6R7S8T                                                                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡ÃƒO:                                                                                 â”‚
-- â”‚   ImplementaÃ§Ã£o pura em PL/pgSQL sem dependÃªncias externas.                                 â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_ulid()
RETURNS TEXT AS $$
DECLARE
    -- Timestamp em milissegundos desde epoch Unix
    unix_time BIGINT;
    -- Parte aleatÃ³ria do ULID
    randomness TEXT := '';
    -- Alfabeto Crockford Base32 (sem I, L, O, U para evitar confusÃ£o)
    encoding TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    -- Resultado final
    output TEXT := '';
    -- VariÃ¡veis auxiliares
    i INT;
    rand_byte INT;
BEGIN
    -- 1. TIMESTAMP (10 caracteres)
    -- ObtÃ©m timestamp atual em milissegundos
    unix_time := (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT;
    
    -- Converte para Base32 (10 chars)
    FOR i IN REVERSE 9..0 LOOP
        output := output || SUBSTRING(encoding FROM ((unix_time >> (i * 5)) & 31) + 1 FOR 1);
    END LOOP;
    
    -- 2. RANDOMNESS (16 caracteres)
    -- Gera 16 caracteres aleatÃ³rios usando Base32
    FOR i IN 1..16 LOOP
        -- Gera nÃºmero aleatÃ³rio entre 0-31
        rand_byte := FLOOR(RANDOM() * 32)::INT;
        randomness := randomness || SUBSTRING(encoding FROM rand_byte + 1 FOR 1);
    END LOOP;
    
    RETURN output || randomness;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_auto_populate_message_fields                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Automatiza o preenchimento de campos de mensagens antes da inserÃ§Ã£o:                      â”‚
-- â”‚   1. Gera source_message_id interno (ULID) para mensagens do sistema                        â”‚
-- â”‚   2. Popula message_content_tsv para busca full-text em portuguÃªs                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   â€¢ source_message_id:                                                                      â”‚
-- â”‚     - Se vazio E sender_type âˆˆ {ai_agent, human_agent, system} â†’ Gera ULID                  â”‚
-- â”‚     - Se jÃ¡ preenchido (mensagem de contact) â†’ MantÃ©m o valor                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚   â€¢ message_content_tsv:                                                                    â”‚
-- â”‚     - Se message_content nÃ£o for NULL â†’ Converte para tsvector portuguÃªs                    â”‚
-- â”‚     - Usa configuraÃ§Ã£o 'portuguese' para stemming correto                                   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELA AFETADA:                                                                             â”‚
-- â”‚   â€¢ 2b_conversation_messages ... (INSERT/UPDATE) Preenche campos automÃ¡ticos                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Executa BEFORE INSERT OR UPDATE                                                         â”‚
-- â”‚   âœ“ Preserva source_message_id de mensagens externas (WhatsApp)                             â”‚
-- â”‚   âœ“ Otimiza busca full-text com tsvector indexado                                           â”‚
-- â”‚   âœ“ Suporta atualizaÃ§Ã£o de mensagens                                                        â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_auto_populate_message_fields()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. GERAR source_message_id INTERNO (apenas para mensagens internas)
    -- Se o campo estÃ¡ vazio/nulo E Ã© uma mensagem interna â†’ gera ULID
    IF (NEW.source_message_id IS NULL OR NEW.source_message_id = '') AND
       NEW.sender_type IN ('ai_agent', 'human_agent', 'system') THEN
        NEW.source_message_id := func_generate_ulid();
    END IF;
    
    -- 2. POPULAR message_content_tsv para busca full-text
    -- Se hÃ¡ conteÃºdo de mensagem â†’ converte para tsvector em portuguÃªs
    IF NEW.message_content IS NOT NULL AND NEW.message_content <> '' THEN
        NEW.message_content_tsv := to_tsvector('portuguese', NEW.message_content);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.5 UTILITÃRIOS AUTOMÃTICOS
-- -------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



-- =================================================================================================
-- FIM DO MÃ“DULO
-- =================================================================================================
-- Para visualizar todos os triggers ativos no banco:
--   SELECT * FROM information_schema.triggers WHERE trigger_schema = 'public';
--
-- Para ver funÃ§Ãµes criadas:
--   SELECT routine_name FROM information_schema.routines 
--   WHERE routine_schema = 'public' AND routine_type = 'FUNCTION';
--
-- Para testar geraÃ§Ã£o de ULID:
--   SELECT func_generate_ulid();
--
-- Para visualizar mensagens e seus IDs:
--   SELECT id, sender_type, source_message_id, 
--          LEFT(message_content, 50) as preview
--   FROM "2b_conversation_messages"
--   ORDER BY message_timestamp DESC;
-- 
-- ==============================================================================================                                                                           â”‚
-- â”‚   âœ“ OperaÃ§Ã£o atÃ´mica (tudo ou nada)                                                         â”‚
-- â”‚   âœ“ Idempotente (pode ser executada mÃºltiplas vezes com seguranÃ§a)                          â”‚
-- â”‚   âœ“ Usa COALESCE para preservar dados existentes quando o parÃ¢metro Ã© NULL                  â”‚
-- â”‚   âœ“ Atualiza updated_at automaticamente                                                     â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_upsert_contact_from_webhook(
  p_inbox_id             UUID,
  p_owner_wallet_id      UUID,
  p_client_name          TEXT DEFAULT NULL,
  p_inbox_name           TEXT DEFAULT NULL,
  p_avatar_inbox_url     TEXT DEFAULT NULL,
  p_login_identity       TEXT DEFAULT NULL,
  p_status_workflow      workflow_status DEFAULT 'ğŸŸ¢',
  p_avatar_agent_url     TEXT DEFAULT NULL,
  p_name_agent           TEXT DEFAULT NULL,
  p_bio_agent            TEXT DEFAULT NULL,
  p_monthly_limit        BIGINT DEFAULT 0,
  p_credits_used         BIGINT DEFAULT 0,
  p_remaining_credits    BIGINT DEFAULT 0,
  p_wallet_id            UUID DEFAULT NULL,
  p_status_contact       workflow_status DEFAULT 'ğŸŸ¢',
  p_status_agent         workflow_status DEFAULT 'ğŸŸ¢',
  p_push_name            TEXT DEFAULT NULL,
  p_latest_avatar_url    TEXT DEFAULT NULL,
  p_phone_number         TEXT DEFAULT NULL,
  p_country_flag_emoji   TEXT DEFAULT NULL,
  p_country_code         VARCHAR DEFAULT NULL,
  p_area_code            VARCHAR DEFAULT NULL,
  p_contact_message_count BIGINT DEFAULT 0,
  p_ai_engagement        BIGINT DEFAULT 0,
  p_human_engagement     BIGINT DEFAULT 0,
  p_engagement_score     FLOAT DEFAULT 0.0,
  p_last_interaction_at  TIMESTAMPTZ DEFAULT NULL,
  p_source_device        TEXT DEFAULT NULL,
  p_energy_daily_credit  BIGINT DEFAULT 0,
  p_energy_current_balance BIGINT DEFAULT 0,
  p_tags                 JSONB DEFAULT '[]'::jsonb,
  p_condensed_memory     JSONB DEFAULT '[]'::jsonb
)
RETURNS void AS $$
BEGIN
  -- ValidaÃ§Ã£o de parÃ¢metros obrigatÃ³rios
  IF p_inbox_id IS NULL OR p_owner_wallet_id IS NULL OR p_wallet_id IS NULL THEN
    RAISE EXCEPTION 'ParÃ¢metros obrigatÃ³rios faltando: inbox_id, owner_wallet_id, wallet_id';
  END IF;

  -- UPSERT Inbox (atÃ´mico e idempotente)
  INSERT INTO "0a_inbox_whatsapp" (
    inbox_id, owner_wallet_id, client_name, inbox_name, avatar_inbox_url,
    login_identity, status_workflow, avatar_agent_url, name_agent, bio_agent,
    monthly_limit, credits_used, remaining_credits, updated_at
  )
  VALUES (
    p_inbox_id, p_owner_wallet_id, p_client_name, p_inbox_name, p_avatar_inbox_url,
    p_login_identity, p_status_workflow, p_avatar_agent_url, p_name_agent, p_bio_agent,
    p_monthly_limit, p_credits_used, p_remaining_credits, NOW()
  )
  ON CONFLICT (inbox_id) DO UPDATE SET
    client_name = COALESCE(EXCLUDED.client_name, "0a_inbox_whatsapp".client_name),
    inbox_name = COALESCE(EXCLUDED.inbox_name, "0a_inbox_whatsapp".inbox_name),
    avatar_inbox_url = COALESCE(EXCLUDED.avatar_inbox_url, "0a_inbox_whatsapp".avatar_inbox_url),
    login_identity = COALESCE(EXCLUDED.login_identity, "0a_inbox_whatsapp".login_identity),
    status_workflow = COALESCE(EXCLUDED.status_workflow, "0a_inbox_whatsapp".status_workflow),
    avatar_agent_url = COALESCE(EXCLUDED.avatar_agent_url, "0a_inbox_whatsapp".avatar_agent_url),
    name_agent = COALESCE(EXCLUDED.name_agent, "0a_inbox_whatsapp".name_agent),
    bio_agent = COALESCE(EXCLUDED.bio_agent, "0a_inbox_whatsapp".bio_agent),
    monthly_limit = COALESCE(EXCLUDED.monthly_limit, "0a_inbox_whatsapp".monthly_limit),
    credits_used = COALESCE(EXCLUDED.credits_used, "0a_inbox_whatsapp".credits_used),
    remaining_credits = COALESCE(EXCLUDED.remaining_credits, "0a_inbox_whatsapp".remaining_credits),
    updated_at = NOW();

  -- UPSERT Contato (atÃ´mico e idempotente)
  INSERT INTO "1a_whatsapp_user_contact" (
    wallet_id, inbox_id, status_contact, status_agent, push_name, latest_avatar_url,
    phone_number, country_flag_emoji, country_code, area_code, contact_message_count,
    ai_engagement, human_engagement, engagement_score, last_interaction_at,
    source_device, energy_daily_credit, energy_current_balance, tags, condensed_memory, updated_at
  )
  VALUES (
    p_wallet_id, p_inbox_id, p_status_contact, p_status_agent, p_push_name, p_latest_avatar_url,
    p_phone_number, p_country_flag_emoji, p_country_code, p_area_code, p_contact_message_count,
    p_ai_engagement, p_human_engagement, p_engagement_score, p_last_interaction_at,
    p_source_device, p_energy_daily_credit, p_energy_current_balance, p_tags, p_condensed_memory, NOW()
  )
  ON CONFLICT (wallet_id) DO UPDATE SET
    status_contact = COALESCE(EXCLUDED.status_contact, "1a_whatsapp_user_contact".status_contact),
    status_agent = COALESCE(EXCLUDED.status_agent, "1a_whatsapp_user_contact".status_agent),
    push_name = COALESCE(EXCLUDED.push_name, "1a_whatsapp_user_contact".push_name),
    latest_avatar_url = COALESCE(EXCLUDED.latest_avatar_url, "1a_whatsapp_user_contact".latest_avatar_url),
    phone_number = COALESCE(EXCLUDED.phone_number, "1a_whatsapp_user_contact".phone_number),
    country_flag_emoji = COALESCE(EXCLUDED.country_flag_emoji, "1a_whatsapp_user_contact".country_flag_emoji),
    country_code = COALESCE(EXCLUDED.country_code, "1a_whatsapp_user_contact".country_code),
    area_code = COALESCE(EXCLUDED.area_code, "1a_whatsapp_user_contact".area_code),
    contact_message_count = COALESCE(EXCLUDED.contact_message_count, "1a_whatsapp_user_contact".contact_message_count),
    ai_engagement = COALESCE(EXCLUDED.ai_engagement, "1a_whatsapp_user_contact".ai_engagement),
    human_engagement = COALESCE(EXCLUDED.human_engagement, "1a_whatsapp_user_contact".human_engagement),
    engagement_score = COALESCE(EXCLUDED.engagement_score, "1a_whatsapp_user_contact".engagement_score),
    last_interaction_at = COALESCE(EXCLUDED.last_interaction_at, "1a_whatsapp_user_contact".last_interaction_at),
    source_device = COALESCE(EXCLUDED.source_device, "1a_whatsapp_user_contact".source_device),
    energy_daily_credit = COALESCE(EXCLUDED.energy_daily_credit, "1a_whatsapp_user_contact".energy_daily_credit),
    energy_current_balance = COALESCE(EXCLUDED.energy_current_balance, "1a_whatsapp_user_contact".energy_current_balance),
    tags = COALESCE(EXCLUDED.tags, "1a_whatsapp_user_contact".tags),
    condensed_memory = COALESCE(EXCLUDED.condensed_memory, "1a_whatsapp_user_contact".condensed_memory),
    updated_at = NOW();

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro na funÃ§Ã£o func_upsert_contact_from_webhook: % - %', SQLERRM, SQLSTATE;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_sync_owner_to_cell_sheet                                                       â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Sincroniza automaticamente o campo 'whatsapp_owner' da tabela 3a para a tabela 3b.        â”‚
-- â”‚   Garante que toda ficha de cliente tenha pelo menos um telefone WhatsApp associado.        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FLUXO:                                                                                      â”‚
-- â”‚   1. Busca o wallet_id na tabela 1a usando phone_number e inbox_id                          â”‚
-- â”‚   2. Se encontrar, faz UPSERT na tabela 3b com is_primary=TRUE                              â”‚
-- â”‚   3. Se nÃ£o encontrar, apenas retorna (aguarda criaÃ§Ã£o do contato)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact ...... (SELECT) Busca wallet_id pelo telefone                  â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service .. (INSERT/UPDATE) Registra telefone primÃ¡rio              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Usada como funÃ§Ã£o de TRIGGER (retorna TRIGGER)                                          â”‚
-- â”‚   â€¢ Executa AFTER INSERT/UPDATE na tabela 3a_customer_root_record                           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_sync_owner_to_cell_sheet()
RETURNS TRIGGER AS $$
DECLARE
    v_wallet_id UUID;
BEGIN
    -- Busca wallet_id do contato usando phone_number e inbox_id
    SELECT wallet_id INTO v_wallet_id
    FROM "1a_whatsapp_user_contact"
    WHERE phone_number = NEW.whatsapp_owner
      AND inbox_id = NEW.inbox_id
    LIMIT 1;

    -- Se o contato ainda nÃ£o existe na tabela 1a, apenas retorna
    IF v_wallet_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- UPSERT do telefone na tabela 3b marcando como primÃ¡rio
    INSERT INTO "3b_cell_phone_linked_service_sheet" (
        root_id,
        wallet_id,
        cell_phone,
        is_primary,
        is_whatsapp,
        verified
    )
    VALUES (
        NEW.id,
        v_wallet_id,
        NEW.whatsapp_owner,
        TRUE,
        TRUE,
        TRUE
    )
    ON CONFLICT (root_id, wallet_id) DO UPDATE SET
        cell_phone = EXCLUDED.cell_phone,
        is_primary = EXCLUDED.is_primary,
        is_whatsapp = EXCLUDED.is_whatsapp,
        verified = EXCLUDED.verified,
        updated_at = NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.2 GERAÃ‡ÃƒO DE IDS AMIGÃVEIS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_client_id                                                    â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para clientes no formato "CT1", "CT2", "CT3"...            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   1. Incrementa atomicamente o contador 'client_count' na tabela 0b_inbox_counters          â”‚
-- â”‚   2. Atribui o valor formatado ao campo 'client_id' do registro sendo inserido              â”‚
-- â”‚   3. Se a inbox nÃ£o tem contador, cria um iniciando em 1                                    â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Thread-safe (usa UPDATE ... RETURNING para atomicidade)                                 â”‚
-- â”‚   âœ“ Cada inbox tem sua prÃ³pria sequÃªncia independente                                       â”‚
-- â”‚   âœ“ Usada como funÃ§Ã£o de TRIGGER (BEFORE INSERT)                                            â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_client_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET client_count = client_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING client_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, new_count, 0)
        ON CONFLICT (inbox_id) DO NOTHING;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.client_id := 'CT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_service_id                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para atendimentos no formato "AT1", "AT2", "AT3"...        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   IdÃªntico Ã  func_generate_friendly_client_id, mas usa o contador 'atendimento_count'       â”‚
-- â”‚   e gera IDs com prefixo "AT" (Atendimento)                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_service_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET atendimento_count = atendimento_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING atendimento_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, 0, new_count)
        ON CONFLICT (inbox_id) DO UPDATE 
        SET atendimento_count = new_count;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.service_id := 'AT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.3 MARCAÃ‡ÃƒO AUTOMÃTICA DE PRIMÃRIO
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_ensure_first_is_primary                                                        â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Garante que o PRIMEIRO registro inserido para uma ficha (root_id) seja automaticamente    â”‚
-- â”‚   marcado como primÃ¡rio (is_primary = TRUE).                                                â”‚
-- â”‚   Registros subsequentes mantÃªm is_primary = FALSE por padrÃ£o.                              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   1. Verifica se jÃ¡ existe algum registro para aquele root_id                               â”‚
-- â”‚   2. Se NÃƒO existir nenhum â†’ forÃ§a is_primary = TRUE (Ã© o primeiro!)                        â”‚
-- â”‚   3. Se JÃ existir algum â†’ mantÃ©m o valor informado (padrÃ£o FALSE)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ APLICÃVEL EM:                                                                               â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service_sheet ... Primeiro telefone                                â”‚
-- â”‚   â€¢ 3e_email ............................ Primeiro e-mail                                   â”‚
-- â”‚   â€¢ 3f_landline_phone ................... Primeiro telefone fixo                            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ GenÃ©rica (funciona em qualquer tabela com root_id e is_primary)                         â”‚
-- â”‚   âœ“ Executa BEFORE INSERT                                                                   â”‚
-- â”‚   âœ“ NÃ£o interfere se o usuÃ¡rio explicitamente definir is_primary = TRUE                     â”‚
-- â”‚   âœ“ Idempotente e thread-safe                                                               â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_ensure_first_is_primary()
RETURNS TRIGGER AS $$
DECLARE
    v_count INT;
BEGIN
    -- Conta quantos registros jÃ¡ existem para este root_id
    EXECUTE format('SELECT COUNT(*) FROM %I WHERE root_id = $1', TG_TABLE_NAME)
    INTO v_count
    USING NEW.root_id;
    
    -- Se nÃ£o existir nenhum registro, este Ã© o primeiro â†’ forÃ§a is_primary = TRUE
    IF v_count = 0 THEN
        NEW.is_primary := TRUE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.4 AUTOMAÃ‡ÃƒO DE MENSAGENS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_ulid                                                                  â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera um ULID (Universally Unique Lexicographically Sortable Identifier) para              â”‚
-- â”‚   rastreamento interno de mensagens.                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS DO ULID:                                                                    â”‚
-- â”‚   â€¢ 26 caracteres (Base32)                                                                  â”‚
-- â”‚   â€¢ OrdenÃ¡vel cronologicamente (timestamp nos primeiros 10 chars)                           â”‚
-- â”‚   â€¢ Mais legÃ­vel que UUID                                                                   â”‚
-- â”‚   â€¢ CompatÃ­vel com Ã­ndices de string                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FORMATO:                                                                                    â”‚
-- â”‚   TTTTTTTTTTRRRRRRRRRRRRRRRR                                                                â”‚
-- â”‚   â””â”€ 10 chars timestamp (milissegundos desde epoch)                                         â”‚
-- â”‚              â””â”€ 16 chars aleatÃ³rios                                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO:                                                                                    â”‚
-- â”‚   01HW5Z8K7F9G2M3N4P5Q6R7S8T                                                                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡ÃƒO:                                                                                 â”‚
-- â”‚   ImplementaÃ§Ã£o pura em PL/pgSQL sem dependÃªncias externas.                                 â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_ulid()
RETURNS TEXT AS $$
DECLARE
    -- Timestamp em milissegundos desde epoch Unix
    unix_time BIGINT;
    -- Parte aleatÃ³ria do ULID
    randomness TEXT := '';
    -- Alfabeto Crockford Base32 (sem I, L, O, U para evitar confusÃ£o)
    encoding TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    -- Resultado final
    output TEXT := '';
    -- VariÃ¡veis auxiliares
    i INT;
    rand_byte INT;
BEGIN
    -- 1. TIMESTAMP (10 caracteres)
    -- ObtÃ©m timestamp atual em milissegundos
    unix_time := (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT;
    
    -- Converte para Base32 (10 chars)
    FOR i IN REVERSE 9..0 LOOP
        output := output || SUBSTRING(encoding FROM ((unix_time >> (i * 5)) & 31) + 1 FOR 1);
    END LOOP;
    
    -- 2. RANDOMNESS (16 caracteres)
    -- Gera 16 caracteres aleatÃ³rios usando Base32
    FOR i IN 1..16 LOOP
        -- Gera nÃºmero aleatÃ³rio entre 0-31
        rand_byte := FLOOR(RANDOM() * 32)::INT;
        randomness := randomness || SUBSTRING(encoding FROM rand_byte + 1 FOR 1);
    END LOOP;
    
    RETURN output || randomness;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_auto_populate_message_fields                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Automatiza o preenchimento de campos de mensagens antes da inserÃ§Ã£o:                      â”‚
-- â”‚   1. Gera source_message_id interno (ULID) para mensagens do sistema                        â”‚
-- â”‚   2. Popula message_content_tsv para busca full-text em portuguÃªs                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   â€¢ source_message_id:                                                                      â”‚
-- â”‚     - Se vazio E sender_type âˆˆ {ai_agent, human_agent, system} â†’ Gera ULID                  â”‚
-- â”‚     - Se jÃ¡ preenchido (mensagem de contact) â†’ MantÃ©m o valor                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚   â€¢ message_content_tsv:                                                                    â”‚
-- â”‚     - Se message_content nÃ£o for NULL â†’ Converte para tsvector portuguÃªs                    â”‚
-- â”‚     - Usa configuraÃ§Ã£o 'portuguese' para stemming correto                                   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELA AFETADA:                                                                             â”‚
-- â”‚   â€¢ 2b_conversation_messages ... (INSERT/UPDATE) Preenche campos automÃ¡ticos                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Executa BEFORE INSERT OR UPDATE                                                         â”‚
-- â”‚   âœ“ Preserva source_message_id de mensagens externas (WhatsApp)                             â”‚
-- â”‚   âœ“ Otimiza busca full-text com tsvector indexado                                           â”‚
-- â”‚   âœ“ Suporta atualizaÃ§Ã£o de mensagens                                                        â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_auto_populate_message_fields()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. GERAR source_message_id INTERNO (apenas para mensagens internas)
    -- Se o campo estÃ¡ vazio/nulo E Ã© uma mensagem interna â†’ gera ULID
    IF (NEW.source_message_id IS NULL OR NEW.source_message_id = '') AND
       NEW.sender_type IN ('ai_agent', 'human_agent', 'system') THEN
        NEW.source_message_id := func_generate_ulid();
    END IF;
    
    -- 2. POPULAR message_content_tsv para busca full-text
    -- Se hÃ¡ conteÃºdo de mensagem â†’ converte para tsvector em portuguÃªs
    IF NEW.message_content IS NOT NULL AND NEW.message_content <> '' THEN
        NEW.message_content_tsv := to_tsvector('portuguese', NEW.message_content);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.5 UTILITÃRIOS AUTOMÃTICOS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: update_updated_at_column                                                            â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Atualiza automaticamente o campo 'updated_at' para NOW() em qualquer operaÃ§Ã£o UPDATE.     â”‚
-- â”‚   Esta Ã© uma funÃ§Ã£o genÃ©rica aplicada a todas as tabelas que possuem a coluna updated_at.   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ USO:                                                                                        â”‚
-- â”‚   Esta funÃ§Ã£o Ã© aplicada automaticamente via trigger dinÃ¢mico (ver triggers.sql).           â”‚
-- â”‚   O sistema descobre todas as tabelas com coluna 'updated_at' e aplica o trigger.           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ COMPORTAMENTO:                                                                              â”‚
-- â”‚   â€¢ Executa BEFORE UPDATE                                                                   â”‚
-- â”‚   â€¢ Atribui NOW() ao campo updated_at do registro sendo atualizado                          â”‚
-- â”‚   â€¢ NÃ£o interfere em operaÃ§Ãµes INSERT (updated_at jÃ¡ tem DEFAULT NOW())                     â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS (aplicado dinamicamente):                                                  â”‚
-- â”‚   â€¢ 0a_inbox_whatsapp                                                                       â”‚
-- â”‚   â€¢ 0b_inbox_counters (se tiver updated_at)                                                 â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact                                                                â”‚
-- â”‚   â€¢ 2b_conversation_messages (se tiver updated_at)                                          â”‚
-- â”‚   â€¢ 3a_customer_root_record                                                                 â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service_sheet                                                      â”‚
-- â”‚   â€¢ 3c_gender                                                                               â”‚
-- â”‚   â€¢ 3d_birth_date                                                                           â”‚
-- â”‚   â€¢ 3e_email                                                                                â”‚
-- â”‚   â€¢ 3f_landline_phone                                                                       â”‚
-- â”‚   â€¢ 3g_cpf                                                                                  â”‚
-- â”‚   â€¢ 3h_rg                                                                                   â”‚
-- â”‚   â€¢ 3i_endereco_br                                                                          â”‚
-- â”‚   â€¢ 4a_customer_service_history                                                             â”‚
-- â”‚   â€¢ ... (qualquer outra tabela com updated_at)                                              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ GenÃ©rica - Funciona em qualquer tabela                                                  â”‚
-- â”‚   âœ“ Transparente - Desenvolvedor nÃ£o precisa se preocupar com updated_at                    â”‚
-- â”‚   âœ“ Consistente - Garante timestamp sempre atualizado                                       â”‚
-- â”‚   âœ“ Performance - Overhead mÃ­nimo (apenas atribuiÃ§Ã£o de timestamp)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO DE USO:                                                                             â”‚
-- â”‚   -- O trigger Ã© aplicado automaticamente, entÃ£o basta fazer UPDATE normal:                 â”‚
-- â”‚   UPDATE "1a_whatsapp_user_contact"                                                         â”‚
-- â”‚   SET push_name = 'Novo Nome'                                                               â”‚
-- â”‚   WHERE wallet_id = 'uuid-123';                                                             â”‚
-- â”‚   -- O campo updated_at serÃ¡ automaticamente atualizado para NOW()                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TRIGGER ASSOCIADO:                                                                          â”‚
-- â”‚   trigger_update_timestamp (criado dinamicamente em triggers.sql)                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Esta funÃ§Ã£o NÃƒO deve ser chamada manualmente                                            â”‚
-- â”‚   â€¢ Ã‰ invocada automaticamente pelo trigger BEFORE UPDATE                                   â”‚
-- â”‚   â€¢ Se uma tabela nÃ£o tiver updated_at, o trigger nÃ£o Ã© aplicado                            â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    -- Atribui o timestamp atual ao campo updated_at do registro sendo atualizado
    NEW.updated_at = NOW();
    
    -- Retorna o registro modificado para que a operaÃ§Ã£o UPDATE continue
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



