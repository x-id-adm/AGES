-- =================================================================================================
-- MÃ“DULO: FUNÃ‡Ã•ES E GATILHOS DO WORKFLOW AGES
-- =================================================================================================
-- DESCRIÃ‡ÃƒO: 
--   Este mÃ³dulo centraliza todas as funÃ§Ãµes de negÃ³cio e triggers do sistema AGES.
--   ResponsÃ¡vel por:
--   - SincronizaÃ§Ã£o de dados entre tabelas
--   - GeraÃ§Ã£o de IDs amigÃ¡veis sequenciais
--   - AtualizaÃ§Ã£o automÃ¡tica de timestamps
--   - ManutenÃ§Ã£o de integridade referencial
-- -------------------------------------------------------------------------------------------------
-- VERSÃƒO: 1.1
-- DATA: 2025-11-14
-- -------------------------------------------------------------------------------------------------

-- =================================================================================================
-- SEÃ‡ÃƒO 1: FUNÃ‡Ã•ES DE NEGÃ“CIO
-- =================================================================================================
-- Esta seÃ§Ã£o contÃ©m as funÃ§Ãµes principais do sistema, organizadas por responsabilidade:
--
-- 1.1 SINCRONIZAÃ‡ÃƒO DE DADOS
--     â””â”€ func_upsert_contact_from_webhook ........ Sincroniza dados do Webhook PING
--     â””â”€ func_sync_owner_to_cell_sheet ........... Propaga whatsapp_owner para cell_phone
--
-- 1.2 GERAÃ‡ÃƒO DE IDS AMIGÃVEIS
--     â””â”€ func_generate_friendly_client_id ........ Gera IDs tipo "CT1", "CT2"...
--     â””â”€ func_generate_friendly_service_id ....... Gera IDs tipo "AT1", "AT2"...
--
-- 1.3 MARCAÃ‡ÃƒO AUTOMÃTICA DE PRIMÃRIO
--     â””â”€ func_ensure_first_is_primary ............ Garante primeiro registro como primÃ¡rio
--
-- 1.4 AUTOMAÃ‡ÃƒO DE MENSAGENS
--     â””â”€ func_generate_ulid ....................... Gera ULID para rastreio
--     â””â”€ func_auto_populate_message_fields ........ Preenche source_message_id e tsvector
--
-- 1.5 UTILITÃRIOS AUTOMÃTICOS
--     â””â”€ update_updated_at_column ................ Atualiza campo updated_at automaticamente
--
-- 1.6 VALIDAÃ‡ÃƒO DE FORMULÃRIO COMPLETO
--     â””â”€ func_check_complete_form ................ Verifica se ficha estÃ¡ completa (baseado em JSON)
--     â””â”€ func_update_form_counter ................ Atualiza contador de fichas completas
--
-- 1.7 CONTADORES DE STATUS DE ATENDIMENTOS
--     â””â”€ func_update_appointment_status_counter .. Atualiza contadores de status automaticamente
-- =================================================================================================


-- -------------------------------------------------------------------------------------------------
-- 1.1 SINCRONIZAÃ‡ÃƒO DE DADOS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_upsert_contact_from_webhook                                                    â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Sincroniza dados recebidos do Webhook PING com as tabelas locais de forma atÃ´mica.        â”‚
-- â”‚   Realiza UPSERT em duas tabelas: inbox e contatos.                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0a_inbox_whatsapp ............. (INSERT/UPDATE) Dados da inbox                          â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact ...... (INSERT/UPDATE) Dados do contato                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ OperaÃ§Ã£o atÃ´mica (tudo ou nada)                                                         â”‚
-- â”‚   âœ“ Idempotente (pode ser executada mÃºltiplas vezes com seguranÃ§a)                          â”‚
-- â”‚   âœ“ Usa COALESCE para preservar dados existentes quando o parÃ¢metro Ã© NULL                  â”‚
-- â”‚   âœ“ Atualiza updated_at automaticamente                                                     â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_upsert_contact_from_webhook(
  p_inbox_id             UUID,
  p_owner_wallet_id      UUID,
  p_client_name          TEXT DEFAULT NULL,
  p_inbox_name           TEXT DEFAULT NULL,
  p_avatar_inbox_url     TEXT DEFAULT NULL,
  p_login_identity       TEXT DEFAULT NULL,
  p_status_workflow      workflow_status DEFAULT 'ğŸŸ¢',
  p_avatar_agent_url     TEXT DEFAULT NULL,
  p_name_agent           TEXT DEFAULT NULL,
  p_bio_agent            TEXT DEFAULT NULL,
  p_monthly_limit        BIGINT DEFAULT 0,
  p_credits_used         BIGINT DEFAULT 0,
  p_remaining_credits    BIGINT DEFAULT 0,
  p_wallet_id            UUID DEFAULT NULL,
  p_status_contact       workflow_status DEFAULT 'ğŸŸ¢',
  p_status_agent         workflow_status DEFAULT 'ğŸŸ¢',
  p_push_name            TEXT DEFAULT NULL,
  p_latest_avatar_url    TEXT DEFAULT NULL,
  p_phone_number         TEXT DEFAULT NULL,
  p_country_flag_emoji   TEXT DEFAULT NULL,
  p_country_code         VARCHAR DEFAULT NULL,
  p_area_code            VARCHAR DEFAULT NULL,
  p_contact_message_count BIGINT DEFAULT 0,
  p_ai_engagement        BIGINT DEFAULT 0,
  p_human_engagement     BIGINT DEFAULT 0,
  p_engagement_score     FLOAT DEFAULT 0.0,
  p_last_interaction_at  TIMESTAMPTZ DEFAULT NULL,
  p_source_device        TEXT DEFAULT NULL,
  p_energy_daily_credit  BIGINT DEFAULT 0,
  p_energy_current_balance BIGINT DEFAULT 0,
  p_tags                 JSONB DEFAULT '[]'::jsonb,
  p_condensed_memory     JSONB DEFAULT '[]'::jsonb
)
RETURNS void AS $$
DECLARE
  v_is_new_contact BOOLEAN;
BEGIN
  -- ValidaÃ§Ã£o de parÃ¢metros obrigatÃ³rios
  IF p_inbox_id IS NULL OR p_owner_wallet_id IS NULL OR p_wallet_id IS NULL THEN
    RAISE EXCEPTION 'ParÃ¢metros obrigatÃ³rios faltando: inbox_id, owner_wallet_id, wallet_id';
  END IF;

  -- UPSERT Inbox (atÃ´mico e idempotente)
  INSERT INTO "0a_inbox_whatsapp" (
    inbox_id, owner_wallet_id, client_name, inbox_name, avatar_inbox_url,
    login_identity, status_workflow, avatar_agent_url, name_agent, bio_agent,
    monthly_limit, credits_used, remaining_credits, updated_at
  )
  VALUES (
    p_inbox_id, p_owner_wallet_id, p_client_name, p_inbox_name, p_avatar_inbox_url,
    p_login_identity, p_status_workflow, p_avatar_agent_url, p_name_agent, p_bio_agent,
    p_monthly_limit, p_credits_used, p_remaining_credits, NOW()
  )
  ON CONFLICT (inbox_id) DO UPDATE SET
    client_name = COALESCE(EXCLUDED.client_name, "0a_inbox_whatsapp".client_name),
    inbox_name = COALESCE(EXCLUDED.inbox_name, "0a_inbox_whatsapp".inbox_name),
    avatar_inbox_url = COALESCE(EXCLUDED.avatar_inbox_url, "0a_inbox_whatsapp".avatar_inbox_url),
    login_identity = COALESCE(EXCLUDED.login_identity, "0a_inbox_whatsapp".login_identity),
    status_workflow = COALESCE(EXCLUDED.status_workflow, "0a_inbox_whatsapp".status_workflow),
    avatar_agent_url = COALESCE(EXCLUDED.avatar_agent_url, "0a_inbox_whatsapp".avatar_agent_url),
    name_agent = COALESCE(EXCLUDED.name_agent, "0a_inbox_whatsapp".name_agent),
    bio_agent = COALESCE(EXCLUDED.bio_agent, "0a_inbox_whatsapp".bio_agent),
    monthly_limit = COALESCE(EXCLUDED.monthly_limit, "0a_inbox_whatsapp".monthly_limit),
    credits_used = COALESCE(EXCLUDED.credits_used, "0a_inbox_whatsapp".credits_used),
    remaining_credits = COALESCE(EXCLUDED.remaining_credits, "0a_inbox_whatsapp".remaining_credits),
    updated_at = NOW();

  -- Verifica se o contato jÃ¡ existe ANTES do UPSERT
  SELECT NOT EXISTS(
    SELECT 1 FROM "1a_whatsapp_user_contact" WHERE wallet_id = p_wallet_id
  ) INTO v_is_new_contact;

  -- UPSERT Contato (atÃ´mico e idempotente)
  INSERT INTO "1a_whatsapp_user_contact" (
    wallet_id, inbox_id, status_contact, status_agent, push_name, latest_avatar_url,
    phone_number, country_flag_emoji, country_code, area_code, contact_message_count,
    ai_engagement, human_engagement, engagement_score, last_interaction_at,
    source_device, energy_daily_credit, energy_current_balance, tags, condensed_memory, updated_at
  )
  VALUES (
    p_wallet_id, p_inbox_id, p_status_contact, p_status_agent, p_push_name, p_latest_avatar_url,
    p_phone_number, p_country_flag_emoji, p_country_code, p_area_code, p_contact_message_count,
    p_ai_engagement, p_human_engagement, p_engagement_score, p_last_interaction_at,
    p_source_device, p_energy_daily_credit, p_energy_current_balance, p_tags, p_condensed_memory, NOW()
  )
  ON CONFLICT (wallet_id) DO UPDATE SET
    status_contact = COALESCE(EXCLUDED.status_contact, "1a_whatsapp_user_contact".status_contact),
    status_agent = COALESCE(EXCLUDED.status_agent, "1a_whatsapp_user_contact".status_agent),
    push_name = COALESCE(EXCLUDED.push_name, "1a_whatsapp_user_contact".push_name),
    latest_avatar_url = COALESCE(EXCLUDED.latest_avatar_url, "1a_whatsapp_user_contact".latest_avatar_url),
    phone_number = COALESCE(EXCLUDED.phone_number, "1a_whatsapp_user_contact".phone_number),
    country_flag_emoji = COALESCE(EXCLUDED.country_flag_emoji, "1a_whatsapp_user_contact".country_flag_emoji),
    country_code = COALESCE(EXCLUDED.country_code, "1a_whatsapp_user_contact".country_code),
    area_code = COALESCE(EXCLUDED.area_code, "1a_whatsapp_user_contact".area_code),
    contact_message_count = COALESCE(EXCLUDED.contact_message_count, "1a_whatsapp_user_contact".contact_message_count),
    ai_engagement = COALESCE(EXCLUDED.ai_engagement, "1a_whatsapp_user_contact".ai_engagement),
    human_engagement = COALESCE(EXCLUDED.human_engagement, "1a_whatsapp_user_contact".human_engagement),
    engagement_score = COALESCE(EXCLUDED.engagement_score, "1a_whatsapp_user_contact".engagement_score),
    last_interaction_at = COALESCE(EXCLUDED.last_interaction_at, "1a_whatsapp_user_contact".last_interaction_at),
    source_device = COALESCE(EXCLUDED.source_device, "1a_whatsapp_user_contact".source_device),
    energy_daily_credit = COALESCE(EXCLUDED.energy_daily_credit, "1a_whatsapp_user_contact".energy_daily_credit),
    energy_current_balance = COALESCE(EXCLUDED.energy_current_balance, "1a_whatsapp_user_contact".energy_current_balance),
    tags = COALESCE(EXCLUDED.tags, "1a_whatsapp_user_contact".tags),
    condensed_memory = COALESCE(EXCLUDED.condensed_memory, "1a_whatsapp_user_contact".condensed_memory),
    updated_at = NOW();

  -- Se Ã© um contato novo, incrementa o contador
  IF v_is_new_contact THEN
    -- Incrementa o contador de contatos da inbox
    UPDATE "0b_inbox_counters"
    SET contact_count = contact_count + 1
    WHERE inbox_id = p_inbox_id;

    -- Se o contador nÃ£o existe, cria um novo
    IF NOT FOUND THEN
      INSERT INTO "0b_inbox_counters" (inbox_id, contact_count, form_count, scheduling_count)
      VALUES (p_inbox_id, 1, 0, 0)
      ON CONFLICT (inbox_id) DO UPDATE
      SET contact_count = "0b_inbox_counters".contact_count + 1;
    END IF;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro na funÃ§Ã£o func_upsert_contact_from_webhook: % - %', SQLERRM, SQLSTATE;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_sync_owner_to_cell_sheet                                                       â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Sincroniza automaticamente o campo 'whatsapp_owner' da tabela 3a para a tabela 3b.        â”‚
-- â”‚   Garante que toda ficha de cliente tenha pelo menos um telefone WhatsApp associado.        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FLUXO:                                                                                      â”‚
-- â”‚   1. Busca o wallet_id na tabela 1a usando phone_number e inbox_id                          â”‚
-- â”‚   2. Se encontrar, faz UPSERT na tabela 3b com is_primary=TRUE                              â”‚
-- â”‚   3. Se nÃ£o encontrar, apenas retorna (aguarda criaÃ§Ã£o do contato)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact ...... (SELECT) Busca wallet_id pelo telefone                  â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service .. (INSERT/UPDATE) Registra telefone primÃ¡rio              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Usada como funÃ§Ã£o de TRIGGER (retorna TRIGGER)                                          â”‚
-- â”‚   â€¢ Executa AFTER INSERT/UPDATE na tabela 3a_customer_root_record                           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_sync_owner_to_cell_sheet()
RETURNS TRIGGER AS $$
DECLARE
    v_wallet_id UUID;
BEGIN
    -- Busca wallet_id do contato usando phone_number e inbox_id
    SELECT wallet_id INTO v_wallet_id
    FROM "1a_whatsapp_user_contact"
    WHERE phone_number = NEW.whatsapp_owner
      AND inbox_id = NEW.inbox_id
    LIMIT 1;

    -- Se o contato ainda nÃ£o existe na tabela 1a, apenas retorna
    IF v_wallet_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- UPSERT do telefone na tabela 3b marcando como primÃ¡rio
    INSERT INTO "3b_cell_phone_linked_service_sheet" (
        root_id,
        wallet_id,
        cell_phone,
        is_primary,
        is_whatsapp,
        verified
    )
    VALUES (
        NEW.id,
        v_wallet_id,
        NEW.whatsapp_owner,
        TRUE,
        TRUE,
        TRUE
    )
    ON CONFLICT (root_id, wallet_id) DO UPDATE SET
        cell_phone = EXCLUDED.cell_phone,
        is_primary = EXCLUDED.is_primary,
        is_whatsapp = EXCLUDED.is_whatsapp,
        verified = EXCLUDED.verified,
        updated_at = NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.2 GERAÃ‡ÃƒO DE IDS AMIGÃVEIS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_client_id                                                    â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para clientes no formato "CT1", "CT2", "CT3"...            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   1. Incrementa atomicamente o contador 'client_count' na tabela 0b_inbox_counters          â”‚
-- â”‚   2. Atribui o valor formatado ao campo 'client_id' do registro sendo inserido              â”‚
-- â”‚   3. Se a inbox nÃ£o tem contador, cria um iniciando em 1                                    â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Thread-safe (usa UPDATE ... RETURNING para atomicidade)                                 â”‚
-- â”‚   âœ“ Cada inbox tem sua prÃ³pria sequÃªncia independente                                       â”‚
-- â”‚   âœ“ Usada como funÃ§Ã£o de TRIGGER (BEFORE INSERT)                                            â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_client_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET client_count = client_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING client_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, new_count, 0)
        ON CONFLICT (inbox_id) DO NOTHING;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.client_id := 'CT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_service_id                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para atendimentos no formato "AT1", "AT2", "AT3"...        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   IdÃªntico Ã  func_generate_friendly_client_id, mas usa o contador 'atendimento_count'       â”‚
-- â”‚   e gera IDs com prefixo "AT" (Atendimento)                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_service_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET atendimento_count = atendimento_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING atendimento_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, 0, new_count)
        ON CONFLICT (inbox_id) DO UPDATE 
        SET atendimento_count = new_count;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.service_id := 'AT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.3 MARCAÃ‡ÃƒO AUTOMÃTICA DE PRIMÃRIO
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_ensure_first_is_primary                                                        â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Garante que o PRIMEIRO registro inserido para uma ficha (root_id) seja automaticamente    â”‚
-- â”‚   marcado como primÃ¡rio (is_primary = TRUE).                                                â”‚
-- â”‚   Registros subsequentes mantÃªm is_primary = FALSE por padrÃ£o.                              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   1. Verifica se jÃ¡ existe algum registro para aquele root_id                               â”‚
-- â”‚   2. Se NÃƒO existir nenhum â†’ forÃ§a is_primary = TRUE (Ã© o primeiro!)                        â”‚
-- â”‚   3. Se JÃ existir algum â†’ mantÃ©m o valor informado (padrÃ£o FALSE)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ APLICÃVEL EM:                                                                               â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service_sheet ... Primeiro telefone                                â”‚
-- â”‚   â€¢ 3e_email ............................ Primeiro e-mail                                   â”‚
-- â”‚   â€¢ 3f_landline_phone ................... Primeiro telefone fixo                            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ GenÃ©rica (funciona em qualquer tabela com root_id e is_primary)                         â”‚
-- â”‚   âœ“ Executa BEFORE INSERT                                                                   â”‚
-- â”‚   âœ“ NÃ£o interfere se o usuÃ¡rio explicitamente definir is_primary = TRUE                     â”‚
-- â”‚   âœ“ Idempotente e thread-safe                                                               â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_ensure_first_is_primary()
RETURNS TRIGGER AS $$
DECLARE
    v_count INT;
BEGIN
    -- Conta quantos registros jÃ¡ existem para este root_id
    EXECUTE format('SELECT COUNT(*) FROM %I WHERE root_id = $1', TG_TABLE_NAME)
    INTO v_count
    USING NEW.root_id;
    
    -- Se nÃ£o existir nenhum registro, este Ã© o primeiro â†’ forÃ§a is_primary = TRUE
    IF v_count = 0 THEN
        NEW.is_primary := TRUE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.4 AUTOMAÃ‡ÃƒO DE MENSAGENS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_ulid                                                                  â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera um ULID (Universally Unique Lexicographically Sortable Identifier) para              â”‚
-- â”‚   rastreamento interno de mensagens.                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS DO ULID:                                                                    â”‚
-- â”‚   â€¢ 26 caracteres (Base32)                                                                  â”‚
-- â”‚   â€¢ OrdenÃ¡vel cronologicamente (timestamp nos primeiros 10 chars)                           â”‚
-- â”‚   â€¢ Mais legÃ­vel que UUID                                                                   â”‚
-- â”‚   â€¢ CompatÃ­vel com Ã­ndices de string                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FORMATO:                                                                                    â”‚
-- â”‚   TTTTTTTTTTRRRRRRRRRRRRRRRR                                                                â”‚
-- â”‚   â””â”€ 10 chars timestamp (milissegundos desde epoch)                                         â”‚
-- â”‚              â””â”€ 16 chars aleatÃ³rios                                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO:                                                                                    â”‚
-- â”‚   01HW5Z8K7F9G2M3N4P5Q6R7S8T                                                                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡ÃƒO:                                                                                 â”‚
-- â”‚   ImplementaÃ§Ã£o pura em PL/pgSQL sem dependÃªncias externas.                                 â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_ulid()
RETURNS TEXT AS $$
DECLARE
    -- Timestamp em milissegundos desde epoch Unix
    unix_time BIGINT;
    -- Parte aleatÃ³ria do ULID
    randomness TEXT := '';
    -- Alfabeto Crockford Base32 (sem I, L, O, U para evitar confusÃ£o)
    encoding TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    -- Resultado final
    output TEXT := '';
    -- VariÃ¡veis auxiliares
    i INT;
    rand_byte INT;
BEGIN
    -- 1. TIMESTAMP (10 caracteres)
    -- ObtÃ©m timestamp atual em milissegundos
    unix_time := (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT;
    
    -- Converte para Base32 (10 chars)
    FOR i IN REVERSE 9..0 LOOP
        output := output || SUBSTRING(encoding FROM ((unix_time >> (i * 5)) & 31) + 1 FOR 1);
    END LOOP;
    
    -- 2. RANDOMNESS (16 caracteres)
    -- Gera 16 caracteres aleatÃ³rios usando Base32
    FOR i IN 1..16 LOOP
        -- Gera nÃºmero aleatÃ³rio entre 0-31
        rand_byte := FLOOR(RANDOM() * 32)::INT;
        randomness := randomness || SUBSTRING(encoding FROM rand_byte + 1 FOR 1);
    END LOOP;
    
    RETURN output || randomness;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_auto_populate_message_fields                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Automatiza o preenchimento de campos de mensagens antes da inserÃ§Ã£o:                      â”‚
-- â”‚   1. Gera source_message_id interno (ULID) para mensagens do sistema                        â”‚
-- â”‚   2. Popula message_content_tsv para busca full-text em portuguÃªs                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   â€¢ source_message_id:                                                                      â”‚
-- â”‚     - Se vazio E sender_type âˆˆ {ai_agent, human_agent, system} â†’ Gera ULID                  â”‚
-- â”‚     - Se jÃ¡ preenchido (mensagem de contact) â†’ MantÃ©m o valor                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚   â€¢ message_content_tsv:                                                                    â”‚
-- â”‚     - Se message_content nÃ£o for NULL â†’ Converte para tsvector portuguÃªs                    â”‚
-- â”‚     - Usa configuraÃ§Ã£o 'portuguese' para stemming correto                                   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELA AFETADA:                                                                             â”‚
-- â”‚   â€¢ 2b_conversation_messages ... (INSERT/UPDATE) Preenche campos automÃ¡ticos                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Executa BEFORE INSERT OR UPDATE                                                         â”‚
-- â”‚   âœ“ Preserva source_message_id de mensagens externas (WhatsApp)                             â”‚
-- â”‚   âœ“ Otimiza busca full-text com tsvector indexado                                           â”‚
-- â”‚   âœ“ Suporta atualizaÃ§Ã£o de mensagens                                                        â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_auto_populate_message_fields()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. GERAR source_message_id INTERNO (apenas para mensagens internas)
    -- Se o campo estÃ¡ vazio/nulo E Ã© uma mensagem interna â†’ gera ULID
    IF (NEW.source_message_id IS NULL OR NEW.source_message_id = '') AND
       NEW.sender_type IN ('ai_agent', 'human_agent', 'system') THEN
        NEW.source_message_id := func_generate_ulid();
    END IF;
    
    -- 2. POPULAR message_content_tsv para busca full-text
    -- Se hÃ¡ conteÃºdo de mensagem â†’ converte para tsvector em portuguÃªs
    IF NEW.message_content IS NOT NULL AND NEW.message_content <> '' THEN
        NEW.message_content_tsv := to_tsvector('portuguese', NEW.message_content);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.5 UTILITÃRIOS AUTOMÃTICOS
-- -------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



-- =================================================================================================
-- FIM DO MÃ“DULO
-- =================================================================================================
-- Para visualizar todos os triggers ativos no banco:
--   SELECT * FROM information_schema.triggers WHERE trigger_schema = 'public';
--
-- Para ver funÃ§Ãµes criadas:
--   SELECT routine_name FROM information_schema.routines 
--   WHERE routine_schema = 'public' AND routine_type = 'FUNCTION';
--
-- Para testar geraÃ§Ã£o de ULID:
--   SELECT func_generate_ulid();
--
-- Para visualizar mensagens e seus IDs:
--   SELECT id, sender_type, source_message_id, 
--          LEFT(message_content, 50) as preview
--   FROM "2b_conversation_messages"
--   ORDER BY message_timestamp DESC;
-- 
-- ==============================================================================================                                                                           â”‚
-- â”‚   âœ“ OperaÃ§Ã£o atÃ´mica (tudo ou nada)                                                         â”‚
-- â”‚   âœ“ Idempotente (pode ser executada mÃºltiplas vezes com seguranÃ§a)                          â”‚
-- â”‚   âœ“ Usa COALESCE para preservar dados existentes quando o parÃ¢metro Ã© NULL                  â”‚
-- â”‚   âœ“ Atualiza updated_at automaticamente                                                     â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_upsert_contact_from_webhook(
  p_inbox_id             UUID,
  p_owner_wallet_id      UUID,
  p_client_name          TEXT DEFAULT NULL,
  p_inbox_name           TEXT DEFAULT NULL,
  p_avatar_inbox_url     TEXT DEFAULT NULL,
  p_login_identity       TEXT DEFAULT NULL,
  p_status_workflow      workflow_status DEFAULT 'ğŸŸ¢',
  p_avatar_agent_url     TEXT DEFAULT NULL,
  p_name_agent           TEXT DEFAULT NULL,
  p_bio_agent            TEXT DEFAULT NULL,
  p_monthly_limit        BIGINT DEFAULT 0,
  p_credits_used         BIGINT DEFAULT 0,
  p_remaining_credits    BIGINT DEFAULT 0,
  p_wallet_id            UUID DEFAULT NULL,
  p_status_contact       workflow_status DEFAULT 'ğŸŸ¢',
  p_status_agent         workflow_status DEFAULT 'ğŸŸ¢',
  p_push_name            TEXT DEFAULT NULL,
  p_latest_avatar_url    TEXT DEFAULT NULL,
  p_phone_number         TEXT DEFAULT NULL,
  p_country_flag_emoji   TEXT DEFAULT NULL,
  p_country_code         VARCHAR DEFAULT NULL,
  p_area_code            VARCHAR DEFAULT NULL,
  p_contact_message_count BIGINT DEFAULT 0,
  p_ai_engagement        BIGINT DEFAULT 0,
  p_human_engagement     BIGINT DEFAULT 0,
  p_engagement_score     FLOAT DEFAULT 0.0,
  p_last_interaction_at  TIMESTAMPTZ DEFAULT NULL,
  p_source_device        TEXT DEFAULT NULL,
  p_energy_daily_credit  BIGINT DEFAULT 0,
  p_energy_current_balance BIGINT DEFAULT 0,
  p_tags                 JSONB DEFAULT '[]'::jsonb,
  p_condensed_memory     JSONB DEFAULT '[]'::jsonb
)
RETURNS void AS $$
DECLARE
  v_is_new_contact BOOLEAN;
BEGIN
  -- ValidaÃ§Ã£o de parÃ¢metros obrigatÃ³rios
  IF p_inbox_id IS NULL OR p_owner_wallet_id IS NULL OR p_wallet_id IS NULL THEN
    RAISE EXCEPTION 'ParÃ¢metros obrigatÃ³rios faltando: inbox_id, owner_wallet_id, wallet_id';
  END IF;

  -- UPSERT Inbox (atÃ´mico e idempotente)
  INSERT INTO "0a_inbox_whatsapp" (
    inbox_id, owner_wallet_id, client_name, inbox_name, avatar_inbox_url,
    login_identity, status_workflow, avatar_agent_url, name_agent, bio_agent,
    monthly_limit, credits_used, remaining_credits, updated_at
  )
  VALUES (
    p_inbox_id, p_owner_wallet_id, p_client_name, p_inbox_name, p_avatar_inbox_url,
    p_login_identity, p_status_workflow, p_avatar_agent_url, p_name_agent, p_bio_agent,
    p_monthly_limit, p_credits_used, p_remaining_credits, NOW()
  )
  ON CONFLICT (inbox_id) DO UPDATE SET
    client_name = COALESCE(EXCLUDED.client_name, "0a_inbox_whatsapp".client_name),
    inbox_name = COALESCE(EXCLUDED.inbox_name, "0a_inbox_whatsapp".inbox_name),
    avatar_inbox_url = COALESCE(EXCLUDED.avatar_inbox_url, "0a_inbox_whatsapp".avatar_inbox_url),
    login_identity = COALESCE(EXCLUDED.login_identity, "0a_inbox_whatsapp".login_identity),
    status_workflow = COALESCE(EXCLUDED.status_workflow, "0a_inbox_whatsapp".status_workflow),
    avatar_agent_url = COALESCE(EXCLUDED.avatar_agent_url, "0a_inbox_whatsapp".avatar_agent_url),
    name_agent = COALESCE(EXCLUDED.name_agent, "0a_inbox_whatsapp".name_agent),
    bio_agent = COALESCE(EXCLUDED.bio_agent, "0a_inbox_whatsapp".bio_agent),
    monthly_limit = COALESCE(EXCLUDED.monthly_limit, "0a_inbox_whatsapp".monthly_limit),
    credits_used = COALESCE(EXCLUDED.credits_used, "0a_inbox_whatsapp".credits_used),
    remaining_credits = COALESCE(EXCLUDED.remaining_credits, "0a_inbox_whatsapp".remaining_credits),
    updated_at = NOW();

  -- Verifica se o contato jÃ¡ existe ANTES do UPSERT
  SELECT NOT EXISTS(
    SELECT 1 FROM "1a_whatsapp_user_contact" WHERE wallet_id = p_wallet_id
  ) INTO v_is_new_contact;

  -- UPSERT Contato (atÃ´mico e idempotente)
  INSERT INTO "1a_whatsapp_user_contact" (
    wallet_id, inbox_id, status_contact, status_agent, push_name, latest_avatar_url,
    phone_number, country_flag_emoji, country_code, area_code, contact_message_count,
    ai_engagement, human_engagement, engagement_score, last_interaction_at,
    source_device, energy_daily_credit, energy_current_balance, tags, condensed_memory, updated_at
  )
  VALUES (
    p_wallet_id, p_inbox_id, p_status_contact, p_status_agent, p_push_name, p_latest_avatar_url,
    p_phone_number, p_country_flag_emoji, p_country_code, p_area_code, p_contact_message_count,
    p_ai_engagement, p_human_engagement, p_engagement_score, p_last_interaction_at,
    p_source_device, p_energy_daily_credit, p_energy_current_balance, p_tags, p_condensed_memory, NOW()
  )
  ON CONFLICT (wallet_id) DO UPDATE SET
    status_contact = COALESCE(EXCLUDED.status_contact, "1a_whatsapp_user_contact".status_contact),
    status_agent = COALESCE(EXCLUDED.status_agent, "1a_whatsapp_user_contact".status_agent),
    push_name = COALESCE(EXCLUDED.push_name, "1a_whatsapp_user_contact".push_name),
    latest_avatar_url = COALESCE(EXCLUDED.latest_avatar_url, "1a_whatsapp_user_contact".latest_avatar_url),
    phone_number = COALESCE(EXCLUDED.phone_number, "1a_whatsapp_user_contact".phone_number),
    country_flag_emoji = COALESCE(EXCLUDED.country_flag_emoji, "1a_whatsapp_user_contact".country_flag_emoji),
    country_code = COALESCE(EXCLUDED.country_code, "1a_whatsapp_user_contact".country_code),
    area_code = COALESCE(EXCLUDED.area_code, "1a_whatsapp_user_contact".area_code),
    contact_message_count = COALESCE(EXCLUDED.contact_message_count, "1a_whatsapp_user_contact".contact_message_count),
    ai_engagement = COALESCE(EXCLUDED.ai_engagement, "1a_whatsapp_user_contact".ai_engagement),
    human_engagement = COALESCE(EXCLUDED.human_engagement, "1a_whatsapp_user_contact".human_engagement),
    engagement_score = COALESCE(EXCLUDED.engagement_score, "1a_whatsapp_user_contact".engagement_score),
    last_interaction_at = COALESCE(EXCLUDED.last_interaction_at, "1a_whatsapp_user_contact".last_interaction_at),
    source_device = COALESCE(EXCLUDED.source_device, "1a_whatsapp_user_contact".source_device),
    energy_daily_credit = COALESCE(EXCLUDED.energy_daily_credit, "1a_whatsapp_user_contact".energy_daily_credit),
    energy_current_balance = COALESCE(EXCLUDED.energy_current_balance, "1a_whatsapp_user_contact".energy_current_balance),
    tags = COALESCE(EXCLUDED.tags, "1a_whatsapp_user_contact".tags),
    condensed_memory = COALESCE(EXCLUDED.condensed_memory, "1a_whatsapp_user_contact".condensed_memory),
    updated_at = NOW();

  -- Se Ã© um contato novo, incrementa o contador
  IF v_is_new_contact THEN
    -- Incrementa o contador de contatos da inbox
    UPDATE "0b_inbox_counters"
    SET contact_count = contact_count + 1
    WHERE inbox_id = p_inbox_id;

    -- Se o contador nÃ£o existe, cria um novo
    IF NOT FOUND THEN
      INSERT INTO "0b_inbox_counters" (inbox_id, contact_count, form_count, scheduling_count)
      VALUES (p_inbox_id, 1, 0, 0)
      ON CONFLICT (inbox_id) DO UPDATE
      SET contact_count = "0b_inbox_counters".contact_count + 1;
    END IF;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro na funÃ§Ã£o func_upsert_contact_from_webhook: % - %', SQLERRM, SQLSTATE;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_sync_owner_to_cell_sheet                                                       â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Sincroniza automaticamente o campo 'whatsapp_owner' da tabela 3a para a tabela 3b.        â”‚
-- â”‚   Garante que toda ficha de cliente tenha pelo menos um telefone WhatsApp associado.        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FLUXO:                                                                                      â”‚
-- â”‚   1. Busca o wallet_id na tabela 1a usando phone_number e inbox_id                          â”‚
-- â”‚   2. Se encontrar, faz UPSERT na tabela 3b com is_primary=TRUE                              â”‚
-- â”‚   3. Se nÃ£o encontrar, apenas retorna (aguarda criaÃ§Ã£o do contato)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact ...... (SELECT) Busca wallet_id pelo telefone                  â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service .. (INSERT/UPDATE) Registra telefone primÃ¡rio              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Usada como funÃ§Ã£o de TRIGGER (retorna TRIGGER)                                          â”‚
-- â”‚   â€¢ Executa AFTER INSERT/UPDATE na tabela 3a_customer_root_record                           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_sync_owner_to_cell_sheet()
RETURNS TRIGGER AS $$
DECLARE
    v_wallet_id UUID;
BEGIN
    -- Busca wallet_id do contato usando phone_number e inbox_id
    SELECT wallet_id INTO v_wallet_id
    FROM "1a_whatsapp_user_contact"
    WHERE phone_number = NEW.whatsapp_owner
      AND inbox_id = NEW.inbox_id
    LIMIT 1;

    -- Se o contato ainda nÃ£o existe na tabela 1a, apenas retorna
    IF v_wallet_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- UPSERT do telefone na tabela 3b marcando como primÃ¡rio
    INSERT INTO "3b_cell_phone_linked_service_sheet" (
        root_id,
        wallet_id,
        cell_phone,
        is_primary,
        is_whatsapp,
        verified
    )
    VALUES (
        NEW.id,
        v_wallet_id,
        NEW.whatsapp_owner,
        TRUE,
        TRUE,
        TRUE
    )
    ON CONFLICT (root_id, wallet_id) DO UPDATE SET
        cell_phone = EXCLUDED.cell_phone,
        is_primary = EXCLUDED.is_primary,
        is_whatsapp = EXCLUDED.is_whatsapp,
        verified = EXCLUDED.verified,
        updated_at = NOW();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.2 GERAÃ‡ÃƒO DE IDS AMIGÃVEIS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_client_id                                                    â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para clientes no formato "CT1", "CT2", "CT3"...            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   1. Incrementa atomicamente o contador 'client_count' na tabela 0b_inbox_counters          â”‚
-- â”‚   2. Atribui o valor formatado ao campo 'client_id' do registro sendo inserido              â”‚
-- â”‚   3. Se a inbox nÃ£o tem contador, cria um iniciando em 1                                    â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Thread-safe (usa UPDATE ... RETURNING para atomicidade)                                 â”‚
-- â”‚   âœ“ Cada inbox tem sua prÃ³pria sequÃªncia independente                                       â”‚
-- â”‚   âœ“ Usada como funÃ§Ã£o de TRIGGER (BEFORE INSERT)                                            â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_client_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET client_count = client_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING client_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, new_count, 0)
        ON CONFLICT (inbox_id) DO NOTHING;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.client_id := 'CT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_friendly_service_id                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera IDs sequenciais amigÃ¡veis para atendimentos no formato "AT1", "AT2", "AT3"...        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FUNCIONAMENTO:                                                                              â”‚
-- â”‚   IdÃªntico Ã  func_generate_friendly_client_id, mas usa o contador 'atendimento_count'       â”‚
-- â”‚   e gera IDs com prefixo "AT" (Atendimento)                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ............. (UPDATE/INSERT) Gerencia contadores por inbox           â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_friendly_service_id()
RETURNS TRIGGER AS $$
DECLARE
    new_count INT;
BEGIN
    -- Incrementa o contador atomicamente e retorna o novo valor
    UPDATE "0b_inbox_counters"
    SET atendimento_count = atendimento_count + 1
    WHERE inbox_id = NEW.inbox_id
    RETURNING atendimento_count INTO new_count;
    
    -- Se nÃ£o houver contador (primeira vez), cria um
    IF NOT FOUND THEN
        new_count := 1;
        INSERT INTO "0b_inbox_counters" (inbox_id, client_count, atendimento_count)
        VALUES (NEW.inbox_id, 0, new_count)
        ON CONFLICT (inbox_id) DO UPDATE 
        SET atendimento_count = new_count;
    END IF;
    
    -- Atribui o ID formatado ao registro
    NEW.service_id := 'AT' || new_count::text;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.3 MARCAÃ‡ÃƒO AUTOMÃTICA DE PRIMÃRIO
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_ensure_first_is_primary                                                        â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Garante que o PRIMEIRO registro inserido para uma ficha (root_id) seja automaticamente    â”‚
-- â”‚   marcado como primÃ¡rio (is_primary = TRUE).                                                â”‚
-- â”‚   Registros subsequentes mantÃªm is_primary = FALSE por padrÃ£o.                              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   1. Verifica se jÃ¡ existe algum registro para aquele root_id                               â”‚
-- â”‚   2. Se NÃƒO existir nenhum â†’ forÃ§a is_primary = TRUE (Ã© o primeiro!)                        â”‚
-- â”‚   3. Se JÃ existir algum â†’ mantÃ©m o valor informado (padrÃ£o FALSE)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ APLICÃVEL EM:                                                                               â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service_sheet ... Primeiro telefone                                â”‚
-- â”‚   â€¢ 3e_email ............................ Primeiro e-mail                                   â”‚
-- â”‚   â€¢ 3f_landline_phone ................... Primeiro telefone fixo                            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ GenÃ©rica (funciona em qualquer tabela com root_id e is_primary)                         â”‚
-- â”‚   âœ“ Executa BEFORE INSERT                                                                   â”‚
-- â”‚   âœ“ NÃ£o interfere se o usuÃ¡rio explicitamente definir is_primary = TRUE                     â”‚
-- â”‚   âœ“ Idempotente e thread-safe                                                               â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_ensure_first_is_primary()
RETURNS TRIGGER AS $$
DECLARE
    v_count INT;
BEGIN
    -- Conta quantos registros jÃ¡ existem para este root_id
    EXECUTE format('SELECT COUNT(*) FROM %I WHERE root_id = $1', TG_TABLE_NAME)
    INTO v_count
    USING NEW.root_id;
    
    -- Se nÃ£o existir nenhum registro, este Ã© o primeiro â†’ forÃ§a is_primary = TRUE
    IF v_count = 0 THEN
        NEW.is_primary := TRUE;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.4 AUTOMAÃ‡ÃƒO DE MENSAGENS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_generate_ulid                                                                  â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Gera um ULID (Universally Unique Lexicographically Sortable Identifier) para              â”‚
-- â”‚   rastreamento interno de mensagens.                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS DO ULID:                                                                    â”‚
-- â”‚   â€¢ 26 caracteres (Base32)                                                                  â”‚
-- â”‚   â€¢ OrdenÃ¡vel cronologicamente (timestamp nos primeiros 10 chars)                           â”‚
-- â”‚   â€¢ Mais legÃ­vel que UUID                                                                   â”‚
-- â”‚   â€¢ CompatÃ­vel com Ã­ndices de string                                                        â”‚
-- â”‚                                                                                             â”‚
-- â”‚ FORMATO:                                                                                    â”‚
-- â”‚   TTTTTTTTTTRRRRRRRRRRRRRRRR                                                                â”‚
-- â”‚   â””â”€ 10 chars timestamp (milissegundos desde epoch)                                         â”‚
-- â”‚              â””â”€ 16 chars aleatÃ³rios                                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO:                                                                                    â”‚
-- â”‚   01HW5Z8K7F9G2M3N4P5Q6R7S8T                                                                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡ÃƒO:                                                                                 â”‚
-- â”‚   ImplementaÃ§Ã£o pura em PL/pgSQL sem dependÃªncias externas.                                 â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_generate_ulid()
RETURNS TEXT AS $$
DECLARE
    -- Timestamp em milissegundos desde epoch Unix
    unix_time BIGINT;
    -- Parte aleatÃ³ria do ULID
    randomness TEXT := '';
    -- Alfabeto Crockford Base32 (sem I, L, O, U para evitar confusÃ£o)
    encoding TEXT := '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
    -- Resultado final
    output TEXT := '';
    -- VariÃ¡veis auxiliares
    i INT;
    rand_byte INT;
BEGIN
    -- 1. TIMESTAMP (10 caracteres)
    -- ObtÃ©m timestamp atual em milissegundos
    unix_time := (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT;
    
    -- Converte para Base32 (10 chars)
    FOR i IN REVERSE 9..0 LOOP
        output := output || SUBSTRING(encoding FROM ((unix_time >> (i * 5)) & 31) + 1 FOR 1);
    END LOOP;
    
    -- 2. RANDOMNESS (16 caracteres)
    -- Gera 16 caracteres aleatÃ³rios usando Base32
    FOR i IN 1..16 LOOP
        -- Gera nÃºmero aleatÃ³rio entre 0-31
        rand_byte := FLOOR(RANDOM() * 32)::INT;
        randomness := randomness || SUBSTRING(encoding FROM rand_byte + 1 FOR 1);
    END LOOP;
    
    RETURN output || randomness;
END;
$$ LANGUAGE plpgsql VOLATILE;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_auto_populate_message_fields                                                   â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Automatiza o preenchimento de campos de mensagens antes da inserÃ§Ã£o:                      â”‚
-- â”‚   1. Gera source_message_id interno (ULID) para mensagens do sistema                        â”‚
-- â”‚   2. Popula message_content_tsv para busca full-text em portuguÃªs                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   â€¢ source_message_id:                                                                      â”‚
-- â”‚     - Se vazio E sender_type âˆˆ {ai_agent, human_agent, system} â†’ Gera ULID                  â”‚
-- â”‚     - Se jÃ¡ preenchido (mensagem de contact) â†’ MantÃ©m o valor                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚   â€¢ message_content_tsv:                                                                    â”‚
-- â”‚     - Se message_content nÃ£o for NULL â†’ Converte para tsvector portuguÃªs                    â”‚
-- â”‚     - Usa configuraÃ§Ã£o 'portuguese' para stemming correto                                   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELA AFETADA:                                                                             â”‚
-- â”‚   â€¢ 2b_conversation_messages ... (INSERT/UPDATE) Preenche campos automÃ¡ticos                â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ Executa BEFORE INSERT OR UPDATE                                                         â”‚
-- â”‚   âœ“ Preserva source_message_id de mensagens externas (WhatsApp)                             â”‚
-- â”‚   âœ“ Otimiza busca full-text com tsvector indexado                                           â”‚
-- â”‚   âœ“ Suporta atualizaÃ§Ã£o de mensagens                                                        â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_auto_populate_message_fields()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. GERAR source_message_id INTERNO (apenas para mensagens internas)
    -- Se o campo estÃ¡ vazio/nulo E Ã© uma mensagem interna â†’ gera ULID
    IF (NEW.source_message_id IS NULL OR NEW.source_message_id = '') AND
       NEW.sender_type IN ('ai_agent', 'human_agent', 'system') THEN
        NEW.source_message_id := func_generate_ulid();
    END IF;
    
    -- 2. POPULAR message_content_tsv para busca full-text
    -- Se hÃ¡ conteÃºdo de mensagem â†’ converte para tsvector em portuguÃªs
    IF NEW.message_content IS NOT NULL AND NEW.message_content <> '' THEN
        NEW.message_content_tsv := to_tsvector('portuguese', NEW.message_content);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.5 UTILITÃRIOS AUTOMÃTICOS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: update_updated_at_column                                                            â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Atualiza automaticamente o campo 'updated_at' para NOW() em qualquer operaÃ§Ã£o UPDATE.     â”‚
-- â”‚   Esta Ã© uma funÃ§Ã£o genÃ©rica aplicada a todas as tabelas que possuem a coluna updated_at.   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ USO:                                                                                        â”‚
-- â”‚   Esta funÃ§Ã£o Ã© aplicada automaticamente via trigger dinÃ¢mico (ver triggers.sql).           â”‚
-- â”‚   O sistema descobre todas as tabelas com coluna 'updated_at' e aplica o trigger.           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ COMPORTAMENTO:                                                                              â”‚
-- â”‚   â€¢ Executa BEFORE UPDATE                                                                   â”‚
-- â”‚   â€¢ Atribui NOW() ao campo updated_at do registro sendo atualizado                          â”‚
-- â”‚   â€¢ NÃ£o interfere em operaÃ§Ãµes INSERT (updated_at jÃ¡ tem DEFAULT NOW())                     â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS (aplicado dinamicamente):                                                  â”‚
-- â”‚   â€¢ 0a_inbox_whatsapp                                                                       â”‚
-- â”‚   â€¢ 0b_inbox_counters (se tiver updated_at)                                                 â”‚
-- â”‚   â€¢ 1a_whatsapp_user_contact                                                                â”‚
-- â”‚   â€¢ 2b_conversation_messages (se tiver updated_at)                                          â”‚
-- â”‚   â€¢ 3a_customer_root_record                                                                 â”‚
-- â”‚   â€¢ 3b_cell_phone_linked_service_sheet                                                      â”‚
-- â”‚   â€¢ 3c_gender                                                                               â”‚
-- â”‚   â€¢ 3d_birth_date                                                                           â”‚
-- â”‚   â€¢ 3e_email                                                                                â”‚
-- â”‚   â€¢ 3f_landline_phone                                                                       â”‚
-- â”‚   â€¢ 3g_cpf                                                                                  â”‚
-- â”‚   â€¢ 3h_rg                                                                                   â”‚
-- â”‚   â€¢ 3i_endereco_br                                                                          â”‚
-- â”‚   â€¢ 4a_customer_service_history                                                             â”‚
-- â”‚   â€¢ ... (qualquer outra tabela com updated_at)                                              â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ GenÃ©rica - Funciona em qualquer tabela                                                  â”‚
-- â”‚   âœ“ Transparente - Desenvolvedor nÃ£o precisa se preocupar com updated_at                    â”‚
-- â”‚   âœ“ Consistente - Garante timestamp sempre atualizado                                       â”‚
-- â”‚   âœ“ Performance - Overhead mÃ­nimo (apenas atribuiÃ§Ã£o de timestamp)                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO DE USO:                                                                             â”‚
-- â”‚   -- O trigger Ã© aplicado automaticamente, entÃ£o basta fazer UPDATE normal:                 â”‚
-- â”‚   UPDATE "1a_whatsapp_user_contact"                                                         â”‚
-- â”‚   SET push_name = 'Novo Nome'                                                               â”‚
-- â”‚   WHERE wallet_id = 'uuid-123';                                                             â”‚
-- â”‚   -- O campo updated_at serÃ¡ automaticamente atualizado para NOW()                          â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TRIGGER ASSOCIADO:                                                                          â”‚
-- â”‚   trigger_update_timestamp (criado dinamicamente em triggers.sql)                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Esta funÃ§Ã£o NÃƒO deve ser chamada manualmente                                            â”‚
-- â”‚   â€¢ Ã‰ invocada automaticamente pelo trigger BEFORE UPDATE                                   â”‚
-- â”‚   â€¢ Se uma tabela nÃ£o tiver updated_at, o trigger nÃ£o Ã© aplicado                            â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    -- Atribui o timestamp atual ao campo updated_at do registro sendo atualizado
    NEW.updated_at = NOW();

    -- Retorna o registro modificado para que a operaÃ§Ã£o UPDATE continue
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.6 VALIDAÃ‡ÃƒO DE FORMULÃRIO COMPLETO
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_check_complete_form                                                            â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Verifica se uma ficha de cliente (3a_customer_root_record) estÃ¡ completa baseado nas      â”‚
-- â”‚   regras de required_data_form configuradas na inbox.                                       â”‚
-- â”‚                                                                                             â”‚
-- â”‚ PARÃ‚METROS:                                                                                 â”‚
-- â”‚   p_root_id (BIGINT) - ID do registro em 3a_customer_root_record                            â”‚
-- â”‚                                                                                             â”‚
-- â”‚ RETORNO:                                                                                    â”‚
-- â”‚   BOOLEAN - TRUE se todos os campos required=true estÃ£o preenchidos, FALSE caso contrÃ¡rio   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   1. Busca o required_data_form da inbox associada ao root_id                               â”‚
-- â”‚   2. Se required_data_form for NULL ou vazio â†’ retorna TRUE (sem regras = completo)         â”‚
-- â”‚   3. Para cada campo no JSON com "required": true:                                          â”‚
-- â”‚      - treatment_name, legal_name_complete, whatsapp_owner â†’ verifica tabela 3a             â”‚
-- â”‚      - gender â†’ verifica tabela 3c                                                          â”‚
-- â”‚      - birth_date â†’ verifica tabela 3d                                                      â”‚
-- â”‚      - email â†’ verifica tabela 3e                                                           â”‚
-- â”‚      - landline_phone â†’ verifica tabela 3f                                                  â”‚
-- â”‚      - cpf â†’ verifica tabela 3g                                                             â”‚
-- â”‚      - rg_numero â†’ verifica tabela 3h                                                       â”‚
-- â”‚      - endereco â†’ verifica tabela 3i (verifica se logradouro + cidade preenchidos)          â”‚
-- â”‚      - cell_phone â†’ verifica tabela 3b                                                      â”‚
-- â”‚   4. Se QUALQUER campo required estiver vazio â†’ retorna FALSE                               â”‚
-- â”‚   5. Se TODOS os campos required estÃ£o preenchidos â†’ retorna TRUE                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO DE required_data_form:                                                              â”‚
-- â”‚   {                                                                                         â”‚
-- â”‚     "treatment_name": { "required": true },                                                 â”‚
-- â”‚     "legal_name_complete": { "required": true },                                            â”‚
-- â”‚     "birth_date": { "required": false },                                                    â”‚
-- â”‚     "email": { "required": false },                                                         â”‚
-- â”‚     "cpf": { "required": true }                                                             â”‚
-- â”‚   }                                                                                         â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS CONSULTADAS:                                                                        â”‚
-- â”‚   â€¢ 0a_inbox_whatsapp ........... (SELECT) Busca required_data_form                         â”‚
-- â”‚   â€¢ 3a_customer_root_record ..... (SELECT) Verifica campos raiz                             â”‚
-- â”‚   â€¢ 3b atÃ© 3i ................... (SELECT) Verifica campos das tabelas filhas               â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ FlexÃ­vel - Cada inbox define suas prÃ³prias regras                                       â”‚
-- â”‚   âœ“ EscalÃ¡vel - Novos campos podem ser adicionados facilmente                               â”‚
-- â”‚   âœ“ Tolerante - Se nÃ£o houver regras definidas, considera completo                          â”‚
-- â”‚   âœ“ PerformÃ¡tico - Usa EXISTS quando possÃ­vel para evitar leitura desnecessÃ¡ria             â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_check_complete_form(p_root_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
    v_inbox_id UUID;
    v_required_config JSONB;
    v_field_name TEXT;
    v_is_required BOOLEAN;
    v_field_value TEXT;
    v_exists BOOLEAN;
BEGIN
    -- 1. Busca inbox_id e required_data_form
    SELECT
        r.inbox_id,
        i.required_data_form
    INTO
        v_inbox_id,
        v_required_config
    FROM "3a_customer_root_record" r
    JOIN "0a_inbox_whatsapp" i ON i.inbox_id = r.inbox_id
    WHERE r.id = p_root_id;

    -- Se nÃ£o encontrou o registro, retorna FALSE
    IF v_inbox_id IS NULL THEN
        RETURN FALSE;
    END IF;

    -- 2. Se nÃ£o hÃ¡ configuraÃ§Ã£o de campos obrigatÃ³rios, considera completo
    IF v_required_config IS NULL OR v_required_config = '{}'::jsonb THEN
        RETURN TRUE;
    END IF;

    -- 3. Itera sobre cada campo no JSON de configuraÃ§Ã£o
    FOR v_field_name, v_is_required IN
        SELECT
            key,
            (value->>'required')::boolean
        FROM jsonb_each(v_required_config)
    LOOP
        -- SÃ³ valida se o campo Ã© obrigatÃ³rio
        IF v_is_required THEN
            -- 4. Verifica cada campo baseado em sua localizaÃ§Ã£o
            CASE v_field_name
                -- Campos da tabela raiz 3a
                WHEN 'treatment_name' THEN
                    SELECT treatment_name INTO v_field_value
                    FROM "3a_customer_root_record"
                    WHERE id = p_root_id;

                    IF v_field_value IS NULL OR v_field_value = '' THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'legal_name_complete' THEN
                    SELECT legal_name_complete INTO v_field_value
                    FROM "3a_customer_root_record"
                    WHERE id = p_root_id;

                    IF v_field_value IS NULL OR v_field_value = '' THEN
                        RETURN FALSE;
                    END IF;

                WHEN 'whatsapp_owner' THEN
                    SELECT whatsapp_owner INTO v_field_value
                    FROM "3a_customer_root_record"
                    WHERE id = p_root_id;

                    IF v_field_value IS NULL OR v_field_value = '' THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3b - cell_phone
                WHEN 'cell_phone' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3b_cell_phone_linked_service_sheet"
                        WHERE root_id = p_root_id
                        AND cell_phone IS NOT NULL
                        AND cell_phone <> ''
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3c - gender
                WHEN 'gender' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3c_gender"
                        WHERE root_id = p_root_id
                        AND gender IS NOT NULL
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3d - birth_date
                WHEN 'birth_date' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3d_birth_date"
                        WHERE root_id = p_root_id
                        AND birth_date IS NOT NULL
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3e - email
                WHEN 'email' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3e_email"
                        WHERE root_id = p_root_id
                        AND email IS NOT NULL
                        AND email <> ''
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3f - landline_phone
                WHEN 'landline_phone' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3f_landline_phone"
                        WHERE root_id = p_root_id
                        AND phone_number IS NOT NULL
                        AND phone_number <> ''
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3g - cpf
                WHEN 'cpf' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3g_cpf"
                        WHERE root_id = p_root_id
                        AND cpf IS NOT NULL
                        AND cpf <> ''
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3h - rg_numero
                WHEN 'rg_numero' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3h_rg"
                        WHERE root_id = p_root_id
                        AND rg_numero IS NOT NULL
                        AND rg_numero <> ''
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                -- Tabela 3i - endereco (verifica logradouro E cidade)
                WHEN 'endereco' THEN
                    SELECT EXISTS(
                        SELECT 1 FROM "3i_endereco_br"
                        WHERE root_id = p_root_id
                        AND logradouro IS NOT NULL
                        AND logradouro <> ''
                        AND cidade IS NOT NULL
                        AND cidade <> ''
                    ) INTO v_exists;

                    IF NOT v_exists THEN
                        RETURN FALSE;
                    END IF;

                ELSE
                    -- Campo nÃ£o reconhecido, ignora
                    NULL;
            END CASE;
        END IF;
    END LOOP;

    -- 5. Se passou por todas as validaÃ§Ãµes, o formulÃ¡rio estÃ¡ completo
    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        -- Em caso de erro, considera incompleto
        RAISE WARNING 'Erro em func_check_complete_form para root_id %: % - %',
                      p_root_id, SQLERRM, SQLSTATE;
        RETURN FALSE;
END;
$$ LANGUAGE plpgsql;


-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_update_form_counter                                                            â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Atualiza automaticamente o contador de fichas completas (form_count) quando uma ficha     â”‚
-- â”‚   de cliente atinge completude baseado nas regras de required_data_form da inbox.           â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TIPO:                                                                                       â”‚
-- â”‚   TRIGGER FUNCTION - Invocada automaticamente apÃ³s INSERT/UPDATE nas tabelas do NÃVEL 3     â”‚
-- â”‚                                                                                             â”‚
-- â”‚ RETORNO:                                                                                    â”‚
-- â”‚   TRIGGER - Retorna NEW para permitir continuaÃ§Ã£o da operaÃ§Ã£o                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   1. Identifica o root_id da ficha afetada (varia por tabela)                               â”‚
-- â”‚   2. Chama func_check_complete_form(root_id) para verificar completude                      â”‚
-- â”‚   3. Compara resultado com o estado atual (is_form_complete):                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚      CASO A: FormulÃ¡rio COMPLETO E estava marcado como INCOMPLETO                           â”‚
-- â”‚      â†’ Marca is_form_complete = TRUE na tabela 3a                                           â”‚
-- â”‚      â†’ Incrementa form_count em 0b_inbox_counters                                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚      CASO B: FormulÃ¡rio INCOMPLETO E estava marcado como COMPLETO                           â”‚
-- â”‚      â†’ Marca is_form_complete = FALSE na tabela 3a                                          â”‚
-- â”‚      â†’ Decrementa form_count em 0b_inbox_counters                                           â”‚
-- â”‚                                                                                             â”‚
-- â”‚      CASO C: Estado nÃ£o mudou (completoâ†’completo ou incompletoâ†’incompleto)                  â”‚
-- â”‚      â†’ NÃ£o faz nada (performance otimizada)                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 3a_customer_root_record ..... (UPDATE) Atualiza is_form_complete                        â”‚
-- â”‚   â€¢ 0b_inbox_counters ........... (UPDATE) Incrementa/decrementa form_count                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚ COMPATIBILIDADE:                                                                            â”‚
-- â”‚   Esta funÃ§Ã£o funciona com triggers de diferentes tabelas do NÃVEL 3:                       â”‚
-- â”‚   â€¢ 3a_customer_root_record ... NEW.id Ã© o root_id                                          â”‚
-- â”‚   â€¢ 3b atÃ© 3i ................. NEW.root_id Ã© a referÃªncia                                  â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ AtÃ´mico - Incremento/decremento Ã© thread-safe                                           â”‚
-- â”‚   âœ“ Inteligente - SÃ³ atualiza quando hÃ¡ mudanÃ§a de estado                                   â”‚
-- â”‚   âœ“ Bidirecional - Detecta tanto completude quanto incompletude                             â”‚
-- â”‚   âœ“ Resiliente - NÃ£o falha se contador nÃ£o existir (cria automaticamente)                   â”‚
-- â”‚                                                                                             â”‚
-- â”‚ OBSERVAÃ‡Ã•ES:                                                                                â”‚
-- â”‚   â€¢ Esta funÃ§Ã£o deve ser aplicada via trigger AFTER INSERT OR UPDATE                        â”‚
-- â”‚   â€¢ Ã‰ executada APÃ“S a inserÃ§Ã£o/atualizaÃ§Ã£o para garantir dados consistentes                â”‚
-- â”‚   â€¢ Triggers devem ser criados em TODAS as tabelas do NÃVEL 3 (3a atÃ© 3i)                   â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_update_form_counter()
RETURNS TRIGGER AS $$
DECLARE
    v_root_id BIGINT;
    v_inbox_id UUID;
    v_is_complete_now BOOLEAN;
    v_was_complete_before BOOLEAN;
BEGIN
    -- 1. Identifica o root_id baseado na tabela que disparou o trigger
    IF TG_TABLE_NAME = '3a_customer_root_record' THEN
        v_root_id := NEW.id;
    ELSE
        v_root_id := NEW.root_id;
    END IF;

    -- Se nÃ£o conseguiu identificar root_id, retorna sem fazer nada
    IF v_root_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- 2. Busca inbox_id e estado atual de completude
    SELECT inbox_id, is_form_complete
    INTO v_inbox_id, v_was_complete_before
    FROM "3a_customer_root_record"
    WHERE id = v_root_id;

    -- Se nÃ£o encontrou o registro raiz, retorna
    IF v_inbox_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- 3. Verifica se o formulÃ¡rio estÃ¡ completo agora
    v_is_complete_now := func_check_complete_form(v_root_id);

    -- 4. Compara estado anterior com estado atual e age conforme necessÃ¡rio
    IF v_is_complete_now AND NOT v_was_complete_before THEN
        -- CASO A: Ficou completo agora! ğŸ‰

        -- Marca como completo na tabela raiz
        UPDATE "3a_customer_root_record"
        SET is_form_complete = TRUE
        WHERE id = v_root_id;

        -- Incrementa o contador de fichas completas
        UPDATE "0b_inbox_counters"
        SET form_count = form_count + 1
        WHERE inbox_id = v_inbox_id;

        -- Se o contador nÃ£o existe, cria
        IF NOT FOUND THEN
            INSERT INTO "0b_inbox_counters" (inbox_id, contact_count, form_count, scheduling_count)
            VALUES (v_inbox_id, 0, 1, 0)
            ON CONFLICT (inbox_id) DO UPDATE
            SET form_count = "0b_inbox_counters".form_count + 1;
        END IF;

    ELSIF NOT v_is_complete_now AND v_was_complete_before THEN
        -- CASO B: Ficou incompleto (dados foram removidos)

        -- Marca como incompleto na tabela raiz
        UPDATE "3a_customer_root_record"
        SET is_form_complete = FALSE
        WHERE id = v_root_id;

        -- Decrementa o contador (com proteÃ§Ã£o contra negativo)
        UPDATE "0b_inbox_counters"
        SET form_count = GREATEST(form_count - 1, 0)
        WHERE inbox_id = v_inbox_id;

    -- ELSE: Estado nÃ£o mudou, nÃ£o faz nada (otimizaÃ§Ã£o de performance)
    END IF;

    RETURN NEW;

EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'Erro em func_update_form_counter para root_id %: % - %',
                      v_root_id, SQLERRM, SQLSTATE;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- -------------------------------------------------------------------------------------------------
-- 1.7 CONTADORES DE STATUS DE ATENDIMENTOS
-- -------------------------------------------------------------------------------------------------

-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-- â”‚ FUNÃ‡ÃƒO: func_update_appointment_status_counter                                              â”‚
-- â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-- â”‚ PROPÃ“SITO:                                                                                  â”‚
-- â”‚   Atualiza automaticamente os contadores de status de atendimentos quando um atendimento    â”‚
-- â”‚   Ã© criado ou tem seu status alterado.                                                      â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TIPO:                                                                                       â”‚
-- â”‚   TRIGGER FUNCTION - Invocada automaticamente apÃ³s INSERT/UPDATE em 4a_customer_service_historyâ”‚
-- â”‚                                                                                             â”‚
-- â”‚ RETORNO:                                                                                    â”‚
-- â”‚   TRIGGER - Retorna NEW para permitir continuaÃ§Ã£o da operaÃ§Ã£o                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚ LÃ“GICA:                                                                                     â”‚
-- â”‚   CASO INSERT (novo atendimento):                                                           â”‚
-- â”‚     â†’ Incrementa o contador correspondente ao novo status                                   â”‚
-- â”‚                                                                                             â”‚
-- â”‚   CASO UPDATE (mudanÃ§a de status):                                                          â”‚
-- â”‚     â†’ Decrementa o contador do status antigo                                                â”‚
-- â”‚     â†’ Incrementa o contador do novo status                                                  â”‚
-- â”‚                                                                                             â”‚
-- â”‚ STATUS MAPEADOS:                                                                            â”‚
-- â”‚   â€¢ 'Scheduled' .......... scheduled_count (mudado pelo Agente de IA)                       â”‚
-- â”‚   â€¢ 'Confirmed' .......... confirmed_count (mudado pelo Agente de IA)                       â”‚
-- â”‚   â€¢ 'Completed' .......... completed_count (mudado pelo Humano)                             â”‚
-- â”‚   â€¢ 'Cancelled' .......... cancelled_count (mudado pelo Humano/IA)                          â”‚
-- â”‚   â€¢ 'Rescheduled' ........ rescheduled_count (mudado pelo Humano)                           â”‚
-- â”‚   â€¢ 'No_Show' ............ no_show_count (mudado pelo Humano)                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚ TABELAS AFETADAS:                                                                           â”‚
-- â”‚   â€¢ 0b_inbox_counters ..... (UPDATE) Incrementa/decrementa contadores de status             â”‚
-- â”‚                                                                                             â”‚
-- â”‚ CARACTERÃSTICAS:                                                                            â”‚
-- â”‚   âœ“ AtÃ´mico - OperaÃ§Ãµes de incremento/decremento sÃ£o thread-safe                            â”‚
-- â”‚   âœ“ Inteligente - SÃ³ atualiza quando hÃ¡ mudanÃ§a real de status                              â”‚
-- â”‚   âœ“ Bidirecional - Detecta inserÃ§Ã£o e atualizaÃ§Ã£o de status                                 â”‚
-- â”‚   âœ“ Resiliente - NÃ£o falha se contador nÃ£o existir (cria automaticamente)                   â”‚
-- â”‚   âœ“ Seguro - ProteÃ§Ã£o contra valores negativos com GREATEST()                               â”‚
-- â”‚                                                                                             â”‚
-- â”‚ EXEMPLO DE FLUXO:                                                                           â”‚
-- â”‚   1. INSERT novo atendimento com status 'Scheduled'                                         â”‚
-- â”‚      â†’ scheduled_count += 1                                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚   2. UPDATE status de 'Scheduled' para 'Confirmed'                                          â”‚
-- â”‚      â†’ scheduled_count -= 1                                                                 â”‚
-- â”‚      â†’ confirmed_count += 1                                                                 â”‚
-- â”‚                                                                                             â”‚
-- â”‚   3. UPDATE status de 'Confirmed' para 'Completed'                                          â”‚
-- â”‚      â†’ confirmed_count -= 1                                                                 â”‚
-- â”‚      â†’ completed_count += 1                                                                 â”‚
-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
CREATE OR REPLACE FUNCTION func_update_appointment_status_counter()
RETURNS TRIGGER AS $$
DECLARE
    v_inbox_id UUID;
    v_old_status TEXT;
    v_new_status TEXT;
BEGIN
    -- Identifica o inbox_id do atendimento
    v_inbox_id := NEW.inbox_id;

    -- Inicializa o novo status
    v_new_status := NEW.service_status;

    -- Para operaÃ§Ãµes de INSERT
    IF (TG_OP = 'INSERT') THEN
        -- Incrementa o contador do novo status
        CASE v_new_status
            WHEN 'Scheduled' THEN
                UPDATE "0b_inbox_counters"
                SET scheduled_count = scheduled_count + 1
                WHERE inbox_id = v_inbox_id;

            WHEN 'Confirmed' THEN
                UPDATE "0b_inbox_counters"
                SET confirmed_count = confirmed_count + 1
                WHERE inbox_id = v_inbox_id;

            WHEN 'Completed' THEN
                UPDATE "0b_inbox_counters"
                SET completed_count = completed_count + 1
                WHERE inbox_id = v_inbox_id;

            WHEN 'Cancelled' THEN
                UPDATE "0b_inbox_counters"
                SET cancelled_count = cancelled_count + 1
                WHERE inbox_id = v_inbox_id;

            WHEN 'Rescheduled' THEN
                UPDATE "0b_inbox_counters"
                SET rescheduled_count = rescheduled_count + 1
                WHERE inbox_id = v_inbox_id;

            WHEN 'No_Show' THEN
                UPDATE "0b_inbox_counters"
                SET no_show_count = no_show_count + 1
                WHERE inbox_id = v_inbox_id;
        END CASE;

        -- Se o contador nÃ£o existe, cria um novo
        IF NOT FOUND THEN
            INSERT INTO "0b_inbox_counters" (
                inbox_id,
                contact_count,
                form_count,
                scheduling_count,
                scheduled_count,
                confirmed_count,
                completed_count,
                cancelled_count,
                rescheduled_count,
                no_show_count
            )
            VALUES (
                v_inbox_id,
                0,
                0,
                0,
                CASE WHEN v_new_status = 'Scheduled' THEN 1 ELSE 0 END,
                CASE WHEN v_new_status = 'Confirmed' THEN 1 ELSE 0 END,
                CASE WHEN v_new_status = 'Completed' THEN 1 ELSE 0 END,
                CASE WHEN v_new_status = 'Cancelled' THEN 1 ELSE 0 END,
                CASE WHEN v_new_status = 'Rescheduled' THEN 1 ELSE 0 END,
                CASE WHEN v_new_status = 'No_Show' THEN 1 ELSE 0 END
            )
            ON CONFLICT (inbox_id) DO UPDATE SET
                scheduled_count = CASE WHEN v_new_status = 'Scheduled'
                    THEN "0b_inbox_counters".scheduled_count + 1
                    ELSE "0b_inbox_counters".scheduled_count END,
                confirmed_count = CASE WHEN v_new_status = 'Confirmed'
                    THEN "0b_inbox_counters".confirmed_count + 1
                    ELSE "0b_inbox_counters".confirmed_count END,
                completed_count = CASE WHEN v_new_status = 'Completed'
                    THEN "0b_inbox_counters".completed_count + 1
                    ELSE "0b_inbox_counters".completed_count END,
                cancelled_count = CASE WHEN v_new_status = 'Cancelled'
                    THEN "0b_inbox_counters".cancelled_count + 1
                    ELSE "0b_inbox_counters".cancelled_count END,
                rescheduled_count = CASE WHEN v_new_status = 'Rescheduled'
                    THEN "0b_inbox_counters".rescheduled_count + 1
                    ELSE "0b_inbox_counters".rescheduled_count END,
                no_show_count = CASE WHEN v_new_status = 'No_Show'
                    THEN "0b_inbox_counters".no_show_count + 1
                    ELSE "0b_inbox_counters".no_show_count END;
        END IF;

    -- Para operaÃ§Ãµes de UPDATE
    ELSIF (TG_OP = 'UPDATE') THEN
        v_old_status := OLD.service_status;

        -- SÃ³ atualiza se o status mudou
        IF v_old_status IS DISTINCT FROM v_new_status THEN
            -- Decrementa o contador do status antigo
            CASE v_old_status
                WHEN 'Scheduled' THEN
                    UPDATE "0b_inbox_counters"
                    SET scheduled_count = GREATEST(scheduled_count - 1, 0)
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Confirmed' THEN
                    UPDATE "0b_inbox_counters"
                    SET confirmed_count = GREATEST(confirmed_count - 1, 0)
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Completed' THEN
                    UPDATE "0b_inbox_counters"
                    SET completed_count = GREATEST(completed_count - 1, 0)
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Cancelled' THEN
                    UPDATE "0b_inbox_counters"
                    SET cancelled_count = GREATEST(cancelled_count - 1, 0)
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Rescheduled' THEN
                    UPDATE "0b_inbox_counters"
                    SET rescheduled_count = GREATEST(rescheduled_count - 1, 0)
                    WHERE inbox_id = v_inbox_id;

                WHEN 'No_Show' THEN
                    UPDATE "0b_inbox_counters"
                    SET no_show_count = GREATEST(no_show_count - 1, 0)
                    WHERE inbox_id = v_inbox_id;
            END CASE;

            -- Incrementa o contador do novo status
            CASE v_new_status
                WHEN 'Scheduled' THEN
                    UPDATE "0b_inbox_counters"
                    SET scheduled_count = scheduled_count + 1
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Confirmed' THEN
                    UPDATE "0b_inbox_counters"
                    SET confirmed_count = confirmed_count + 1
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Completed' THEN
                    UPDATE "0b_inbox_counters"
                    SET completed_count = completed_count + 1
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Cancelled' THEN
                    UPDATE "0b_inbox_counters"
                    SET cancelled_count = cancelled_count + 1
                    WHERE inbox_id = v_inbox_id;

                WHEN 'Rescheduled' THEN
                    UPDATE "0b_inbox_counters"
                    SET rescheduled_count = rescheduled_count + 1
                    WHERE inbox_id = v_inbox_id;

                WHEN 'No_Show' THEN
                    UPDATE "0b_inbox_counters"
                    SET no_show_count = no_show_count + 1
                    WHERE inbox_id = v_inbox_id;
            END CASE;
        END IF;
    END IF;

    RETURN NEW;

EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING 'Erro em func_update_appointment_status_counter para inbox_id %: % - %',
                      v_inbox_id, SQLERRM, SQLSTATE;
        RETURN NEW;
END;
$$ LANGUAGE plpgsql;


